//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import { DateTime, Duration } from "luxon";

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class AbpServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param includeTypes (optional) 
     * @return Success
     */
    apiDefinition(includeTypes: boolean | undefined): Observable<ApplicationApiDescriptionModel> {
        let url_ = this.baseUrl + "/api/abp/api-definition?";
        if (includeTypes === null)
            throw new Error("The parameter 'includeTypes' cannot be null.");
        else if (includeTypes !== undefined)
            url_ += "IncludeTypes=" + encodeURIComponent("" + includeTypes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiDefinition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationApiDescriptionModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationApiDescriptionModel>;
        }));
    }

    protected processApiDefinition(response: HttpResponseBase): Observable<ApplicationApiDescriptionModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationApiDescriptionModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationApiDescriptionModel>(null as any);
    }

    /**
     * @return Success
     */
    applicationConfiguration(): Observable<ApplicationConfigurationDto> {
        let url_ = this.baseUrl + "/api/abp/application-configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApplicationConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApplicationConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationConfigurationDto>;
        }));
    }

    protected processApplicationConfiguration(response: HttpResponseBase): Observable<ApplicationConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationConfigurationDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: Body | undefined): Observable<LoginResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/account/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = Object.keys(body as any).map((key) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent((body as any)[key]);
        }).join('&')

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/x-www-form-urlencoded",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResultDto>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: Body2 | undefined): Observable<LoginResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/account/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = Object.keys(body as any).map((key) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent((body as any)[key]);
        }).join('&')

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/x-www-form-urlencoded",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResultDto>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<LoginResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    refreshToken(body: Body3 | undefined): Observable<AuthJwtDto> {
        let url_ = this.baseUrl + "/api/danh-muc/account/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = Object.keys(body as any).map((key) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent((body as any)[key]);
        }).join('&')

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/x-www-form-urlencoded",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthJwtDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthJwtDto>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<AuthJwtDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthJwtDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthJwtDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    passwordlessLogin(body: AccountPasswordlessLoginQuery | undefined): Observable<AuthJwtDto> {
        let url_ = this.baseUrl + "/api/danh-muc/account/passwordless-login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPasswordlessLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPasswordlessLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthJwtDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthJwtDto>;
        }));
    }

    protected processPasswordlessLogin(response: HttpResponseBase): Observable<AuthJwtDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthJwtDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthJwtDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class BookingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paginglist(body: PagingListBookingRequest | undefined): Observable<ThongTinChungBookingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/booking/paginglist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaginglist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaginglist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThongTinChungBookingDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThongTinChungBookingDtoPagedResultDto>;
        }));
    }

    protected processPaginglist(response: HttpResponseBase): Observable<ThongTinChungBookingDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThongTinChungBookingDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThongTinChungBookingDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createorupdate(body: CreateOrUpdateBookingRequest | undefined): Observable<Int64CommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/booking/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64CommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64CommonResultDto>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<Int64CommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64CommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64CommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getbyid(body: GetBookingByIdRequest | undefined): Observable<BookingDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/booking/getbyid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BookingDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BookingDtoCommonResultDto>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<BookingDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BookingDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BookingDtoCommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paginglistthanhviendoan(body: PagingListThanhVienDoanRequest | undefined): Observable<ChiTietThanhVienDoanDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/booking/paginglistthanhviendoan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaginglistthanhviendoan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaginglistthanhviendoan(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChiTietThanhVienDoanDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChiTietThanhVienDoanDtoPagedResultDto>;
        }));
    }

    protected processPaginglistthanhviendoan(response: HttpResponseBase): Observable<ChiTietThanhVienDoanDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChiTietThanhVienDoanDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChiTietThanhVienDoanDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createorupdatethanhviendoan(body: CreateOrUpdateThanhVienDoanRequest | undefined): Observable<Int64CommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/booking/createorupdatethanhviendoan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdatethanhviendoan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdatethanhviendoan(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64CommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64CommonResultDto>;
        }));
    }

    protected processCreateorupdatethanhviendoan(response: HttpResponseBase): Observable<Int64CommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64CommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64CommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paginglistdichvule(body: PagingDichVuLeRequest | undefined): Observable<ChiTietDichVuLeBookingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/booking/paginglistdichvule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaginglistdichvule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaginglistdichvule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChiTietDichVuLeBookingDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChiTietDichVuLeBookingDtoPagedResultDto>;
        }));
    }

    protected processPaginglistdichvule(response: HttpResponseBase): Observable<ChiTietDichVuLeBookingDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChiTietDichVuLeBookingDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChiTietDichVuLeBookingDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createorupdatedichvule(body: CreateOrUpdateDichVuLeRequest | undefined): Observable<Int64CommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/booking/createorupdatedichvule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdatedichvule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdatedichvule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64CommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64CommonResultDto>;
        }));
    }

    protected processCreateorupdatedichvule(response: HttpResponseBase): Observable<Int64CommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64CommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64CommonResultDto>(null as any);
    }

    /**
     * @param bookingId (optional) 
     * @param trangThai (optional) 
     * @return Success
     */
    thaydoitrangthai(bookingId: number | undefined, trangThai: number | undefined): Observable<BooleanCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/booking/thaydoitrangthai?";
        if (bookingId === null)
            throw new Error("The parameter 'bookingId' cannot be null.");
        else if (bookingId !== undefined)
            url_ += "bookingId=" + encodeURIComponent("" + bookingId) + "&";
        if (trangThai === null)
            throw new Error("The parameter 'trangThai' cannot be null.");
        else if (trangThai !== undefined)
            url_ += "trangThai=" + encodeURIComponent("" + trangThai) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThaydoitrangthai(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThaydoitrangthai(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanCommonResultDto>;
        }));
    }

    protected processThaydoitrangthai(response: HttpResponseBase): Observable<BooleanCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanCommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendemaillienhencc(body: SendEmailLienHeNCCRequest | undefined): Observable<BooleanCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/booking/sendemaillienhencc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendemaillienhencc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendemaillienhencc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanCommonResultDto>;
        }));
    }

    protected processSendemaillienhencc(response: HttpResponseBase): Observable<BooleanCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanCommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    xacnhanhuybooking(body: HuyBookingRequest | undefined): Observable<BooleanCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/booking/xacnhanhuybooking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXacnhanhuybooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXacnhanhuybooking(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanCommonResultDto>;
        }));
    }

    protected processXacnhanhuybooking(response: HttpResponseBase): Observable<BooleanCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanCommonResultDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CodeSystemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getlist(body: PagingCodeSystemRequests | undefined): Observable<CodeSystemDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system/getlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CodeSystemDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CodeSystemDtoPagedResultDto>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<CodeSystemDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CodeSystemDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CodeSystemDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    multiDeleteItem(body: CodeSystemDto[] | null | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system/multi-delete-item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMultiDeleteItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMultiDeleteItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number[]>;
        }));
    }

    protected processMultiDeleteItem(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(null as any);
    }

    /**
     * @return Success
     */
    itemDelete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system/{id}/item-delete";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processItemDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processItemDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processItemDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    codeSystemCreateOrUpdate(body: CodeSystemDto | undefined): Observable<BooleanCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system/code-system-create-or-update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCodeSystemCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCodeSystemCreateOrUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanCommonResultDto>;
        }));
    }

    protected processCodeSystemCreateOrUpdate(response: HttpResponseBase): Observable<BooleanCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanCommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportExcelDanhMucChung(body: ExportExcelCodeSystemRequest | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system/export-excel-danh-muc-chung";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelDanhMucChung(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelDanhMucChung(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportExcelDanhMucChung(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    downloadFtcodeSystem(body: DownloadFTCodeSystemRequest | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system/download-ftcode-system";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFtcodeSystem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFtcodeSystem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processDownloadFtcodeSystem(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkValidImportExcelDanhMucChung(body: CheckValidImportExcelCodeSystemRequest | undefined): Observable<CheckValidImportExcelCodeSystemDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system/check-valid-import-excel-danh-muc-chung";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckValidImportExcelDanhMucChung(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckValidImportExcelDanhMucChung(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckValidImportExcelCodeSystemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckValidImportExcelCodeSystemDto[]>;
        }));
    }

    protected processCheckValidImportExcelDanhMucChung(response: HttpResponseBase): Observable<CheckValidImportExcelCodeSystemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CheckValidImportExcelCodeSystemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckValidImportExcelCodeSystemDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadExcelDanhMucChung(body: UploadExcelCodeSystemRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system/upload-excel-danh-muc-chung";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadExcelDanhMucChung(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadExcelDanhMucChung(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadExcelDanhMucChung(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param parentCode (optional) 
     * @return Success
     */
    byParentCode(parentCode: string | null | undefined): Observable<CodeSystemDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system/by-parent-code?";
        if (parentCode !== undefined && parentCode !== null)
            url_ += "ParentCode=" + encodeURIComponent("" + parentCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processByParentCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processByParentCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CodeSystemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CodeSystemDto[]>;
        }));
    }

    protected processByParentCode(response: HttpResponseBase): Observable<CodeSystemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CodeSystemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CodeSystemDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getbyid(id: number): Observable<CodeSystemDto> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CodeSystemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CodeSystemDto>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<CodeSystemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CodeSystemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CodeSystemDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CodeSystemDto | undefined): Observable<CodeSystemDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CodeSystemDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CodeSystemDtoCommonResultDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CodeSystemDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CodeSystemDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CodeSystemDtoCommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(id: number, body: CodeSystemDto | undefined): Observable<CodeSystemDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CodeSystemDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CodeSystemDtoCommonResultDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CodeSystemDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CodeSystemDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CodeSystemDtoCommonResultDto>(null as any);
    }

    /**
     * @return Success
     */
    removebyid(id: number): Observable<Int64CommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system/removebyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovebyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovebyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64CommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64CommonResultDto>;
        }));
    }

    protected processRemovebyid(response: HttpResponseBase): Observable<Int64CommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64CommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64CommonResultDto>(null as any);
    }

    /**
     * @param isAll (optional) 
     * @param fileType (optional) 
     * @param body (optional) 
     * @return Success
     */
    getlisttofile(isAll: boolean | undefined, fileType: number | undefined, body: PagingCodeSystemRequests | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system/getlisttofile?";
        if (isAll === null)
            throw new Error("The parameter 'isAll' cannot be null.");
        else if (isAll !== undefined)
            url_ += "isAll=" + encodeURIComponent("" + isAll) + "&";
        if (fileType === null)
            throw new Error("The parameter 'fileType' cannot be null.");
        else if (fileType !== undefined)
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlisttofile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlisttofile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetlisttofile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DanhMucServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    codeSystemPost(body: CodeSystemDto | undefined): Observable<CodeSystemDto> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCodeSystemPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCodeSystemPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CodeSystemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CodeSystemDto>;
        }));
    }

    protected processCodeSystemPost(response: HttpResponseBase): Observable<CodeSystemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CodeSystemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CodeSystemDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    codeSystemPut(id: number, body: CodeSystemDto | undefined): Observable<CodeSystemDto> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCodeSystemPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCodeSystemPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CodeSystemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CodeSystemDto>;
        }));
    }

    protected processCodeSystemPut(response: HttpResponseBase): Observable<CodeSystemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CodeSystemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CodeSystemDto>(null as any);
    }

    /**
     * @return Success
     */
    codeSystemDelete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCodeSystemDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCodeSystemDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCodeSystemDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    codeSystemMap(body: CodeSystemMapEntity | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system-map";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCodeSystemMap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCodeSystemMap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCodeSystemMap(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    configSystemPost(body: ConfigSystemDto | undefined): Observable<ConfigSystemDto> {
        let url_ = this.baseUrl + "/api/danh-muc/config-system";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfigSystemPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfigSystemPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSystemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSystemDto>;
        }));
    }

    protected processConfigSystemPost(response: HttpResponseBase): Observable<ConfigSystemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSystemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSystemDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    configSystemPut(id: number, body: ConfigSystemDto | undefined): Observable<ConfigSystemDto> {
        let url_ = this.baseUrl + "/api/danh-muc/config-system/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfigSystemPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfigSystemPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSystemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSystemDto>;
        }));
    }

    protected processConfigSystemPut(response: HttpResponseBase): Observable<ConfigSystemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSystemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSystemDto>(null as any);
    }

    /**
     * @return Success
     */
    configSystemDelete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/config-system/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfigSystemDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfigSystemDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConfigSystemDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    danhMucHuyenPost(body: HuyenDto | undefined): Observable<HuyenDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-huyen";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucHuyenPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucHuyenPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HuyenDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HuyenDto>;
        }));
    }

    protected processDanhMucHuyenPost(response: HttpResponseBase): Observable<HuyenDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HuyenDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HuyenDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    danhMucHuyenPut(id: string | null, body: HuyenDto | undefined): Observable<HuyenDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-huyen/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucHuyenPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucHuyenPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HuyenDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HuyenDto>;
        }));
    }

    protected processDanhMucHuyenPut(response: HttpResponseBase): Observable<HuyenDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HuyenDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HuyenDto>(null as any);
    }

    /**
     * @return Success
     */
    danhMucHuyenDelete(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-huyen/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucHuyenDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucHuyenDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDanhMucHuyenDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    danhMucQuocTichPost(body: QuocTichDto | undefined): Observable<QuocTichDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-quoc-tich";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucQuocTichPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucQuocTichPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuocTichDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuocTichDto>;
        }));
    }

    protected processDanhMucQuocTichPost(response: HttpResponseBase): Observable<QuocTichDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuocTichDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuocTichDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    danhMucQuocTichPut(id: string | null, body: QuocTichDto | undefined): Observable<QuocTichDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-quoc-tich/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucQuocTichPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucQuocTichPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuocTichDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuocTichDto>;
        }));
    }

    protected processDanhMucQuocTichPut(response: HttpResponseBase): Observable<QuocTichDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuocTichDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuocTichDto>(null as any);
    }

    /**
     * @return Success
     */
    danhMucQuocTichDelete(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-quoc-tich/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucQuocTichDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucQuocTichDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDanhMucQuocTichDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    danhMucTinhPost(body: TinhDto | undefined): Observable<TinhDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucTinhPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucTinhPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TinhDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TinhDto>;
        }));
    }

    protected processDanhMucTinhPost(response: HttpResponseBase): Observable<TinhDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TinhDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinhDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    danhMucTinhPut(id: string | null, body: TinhDto | undefined): Observable<TinhDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucTinhPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucTinhPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TinhDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TinhDto>;
        }));
    }

    protected processDanhMucTinhPut(response: HttpResponseBase): Observable<TinhDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TinhDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinhDto>(null as any);
    }

    /**
     * @return Success
     */
    danhMucTinhDelete(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucTinhDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucTinhDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDanhMucTinhDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    danhMucXaPost(body: XaDto | undefined): Observable<XaDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-xa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucXaPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucXaPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XaDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XaDto>;
        }));
    }

    protected processDanhMucXaPost(response: HttpResponseBase): Observable<XaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = XaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XaDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    danhMucXaPut(id: string | null, body: XaDto | undefined): Observable<XaDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-xa/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucXaPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucXaPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XaDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XaDto>;
        }));
    }

    protected processDanhMucXaPut(response: HttpResponseBase): Observable<XaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = XaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XaDto>(null as any);
    }

    /**
     * @return Success
     */
    danhMucXaDelete(id: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-xa/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucXaDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucXaDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDanhMucXaDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tepDinhKemPost(body: TepDinhKemDto | undefined): Observable<TepDinhKemDto> {
        let url_ = this.baseUrl + "/api/danh-muc/tep-dinh-kem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTepDinhKemPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTepDinhKemPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TepDinhKemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TepDinhKemDto>;
        }));
    }

    protected processTepDinhKemPost(response: HttpResponseBase): Observable<TepDinhKemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TepDinhKemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TepDinhKemDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tepDinhKemPut(id: number, body: TepDinhKemDto | undefined): Observable<TepDinhKemDto> {
        let url_ = this.baseUrl + "/api/danh-muc/tep-dinh-kem/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTepDinhKemPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTepDinhKemPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TepDinhKemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TepDinhKemDto>;
        }));
    }

    protected processTepDinhKemPut(response: HttpResponseBase): Observable<TepDinhKemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TepDinhKemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TepDinhKemDto>(null as any);
    }

    /**
     * @return Success
     */
    tepDinhKemDelete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/tep-dinh-kem/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTepDinhKemDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTepDinhKemDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTepDinhKemDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CodeSystemMapServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param codeType (optional) 
     * @return Success
     */
    bySource(codeType: string | null | undefined, sourceId: number): Observable<CodeSystemDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system-map/by-source/{sourceId}?";
        if (sourceId === undefined || sourceId === null)
            throw new Error("The parameter 'sourceId' must be defined.");
        url_ = url_.replace("{sourceId}", encodeURIComponent("" + sourceId));
        if (codeType !== undefined && codeType !== null)
            url_ += "codeType=" + encodeURIComponent("" + codeType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBySource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBySource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CodeSystemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CodeSystemDto[]>;
        }));
    }

    protected processBySource(response: HttpResponseBase): Observable<CodeSystemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CodeSystemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CodeSystemDto[]>(null as any);
    }

    /**
     * @param codeType (optional) 
     * @return Success
     */
    sourceId(codeType: string | null | undefined, destinationId: number): Observable<number> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system-map/source-id/{destinationId}?";
        if (destinationId === undefined || destinationId === null)
            throw new Error("The parameter 'destinationId' must be defined.");
        url_ = url_.replace("{destinationId}", encodeURIComponent("" + destinationId));
        if (codeType !== undefined && codeType !== null)
            url_ += "codeType=" + encodeURIComponent("" + codeType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSourceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSourceId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSourceId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @return Success
     */
    remove(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system-map/{id}/remove";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param codeType (optional) 
     * @return Success
     */
    sourceName(codeType: string | null | undefined, destinationId: number): Observable<CodeSystemDto> {
        let url_ = this.baseUrl + "/api/danh-muc/code-system-map/source-name/{destinationId}?";
        if (destinationId === undefined || destinationId === null)
            throw new Error("The parameter 'destinationId' must be defined.");
        url_ = url_.replace("{destinationId}", encodeURIComponent("" + destinationId));
        if (codeType !== undefined && codeType !== null)
            url_ += "codeType=" + encodeURIComponent("" + codeType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSourceName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSourceName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CodeSystemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CodeSystemDto>;
        }));
    }

    protected processSourceName(response: HttpResponseBase): Observable<CodeSystemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CodeSystemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CodeSystemDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ComboBaseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTreeOrganizationUnit(): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/combo-base/get-tree-organization-unit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTreeOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTreeOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processGetTreeOrganizationUnit(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllOrganizationUnitByUserId(): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/combo-base/get-all-organization-unit-by-user-id";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrganizationUnitByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrganizationUnitByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processGetAllOrganizationUnitByUserId(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CommonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    danhMucHuyenCombo(body: HuyenComboboxRequest | undefined): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/danh-muc-huyen-combo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucHuyenCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucHuyenCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processDanhMucHuyenCombo(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    danhMucXaCombo(body: XaComboboxRequest | undefined): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/danh-muc-xa-combo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucXaCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucXaCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processDanhMucXaCombo(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    phanVungTinh(): Observable<PHAN_VUNG_TINHItemObj[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/phan-vung-tinh";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPhanVungTinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPhanVungTinh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PHAN_VUNG_TINHItemObj[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PHAN_VUNG_TINHItemObj[]>;
        }));
    }

    protected processPhanVungTinh(response: HttpResponseBase): Observable<PHAN_VUNG_TINHItemObj[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PHAN_VUNG_TINHItemObj.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PHAN_VUNG_TINHItemObj[]>(null as any);
    }

    /**
     * @return Success
     */
    trangThaiBooking(): Observable<TRANG_THAI_BOOKINGItemObj[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/trang-thai-booking";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTrangThaiBooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTrangThaiBooking(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TRANG_THAI_BOOKINGItemObj[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TRANG_THAI_BOOKINGItemObj[]>;
        }));
    }

    protected processTrangThaiBooking(response: HttpResponseBase): Observable<TRANG_THAI_BOOKINGItemObj[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TRANG_THAI_BOOKINGItemObj.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TRANG_THAI_BOOKINGItemObj[]>(null as any);
    }

    /**
     * @return Success
     */
    danhMucTinhCombo(): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/danh-muc-tinh-combo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucTinhCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucTinhCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processDanhMucTinhCombo(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    danhMucPhongBanCombo(): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/danh-muc-phong-ban-combo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucPhongBanCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucPhongBanCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processDanhMucPhongBanCombo(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getallusers(): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/getallusers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallusers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallusers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processGetallusers(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getorganizationunitscombobox(): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/getorganizationunitscombobox";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetorganizationunitscombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetorganizationunitscombobox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processGetorganizationunitscombobox(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getsochongoixecombobox(): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/getsochongoixecombobox";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetsochongoixecombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetsochongoixecombobox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processGetsochongoixecombobox(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getloaixecombobox(): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/getloaixecombobox";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetloaixecombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetloaixecombobox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processGetloaixecombobox(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getloaitientecombobox(): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/getloaitientecombobox";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetloaitientecombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetloaitientecombobox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processGetloaitientecombobox(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getloaihopdongcombobox(): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/getloaihopdongcombobox";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetloaihopdongcombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetloaihopdongcombobox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processGetloaihopdongcombobox(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getloaisochoixe(): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/getloaisochoixe";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetloaisochoixe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetloaisochoixe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processGetloaisochoixe(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getloaikhach(): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/getloaikhach";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetloaikhach(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetloaikhach(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processGetloaikhach(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getfromdatabase(body: GetComboDataFromDataBaseInputDto | undefined): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/getfromdatabase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetfromdatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetfromdatabase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processGetfromdatabase(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    codeSystemCombo(): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/code-system-combo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCodeSystemCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCodeSystemCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processCodeSystemCombo(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    danhMucQuocTichCombo(): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/danh-muc-quoc-tich-combo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDanhMucQuocTichCombo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDanhMucQuocTichCombo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processDanhMucQuocTichCombo(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getquocgia(): Observable<ComboBoxDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/common/getquocgia";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetquocgia(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetquocgia(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDto[]>;
        }));
    }

    protected processGetquocgia(response: HttpResponseBase): Observable<ComboBoxDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboBoxDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDto[]>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CommonEnumServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    enum(): Observable<CommonEnumDto> {
        let url_ = this.baseUrl + "/api/danh-muc/common-enum/enum";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnum(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommonEnumDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommonEnumDto>;
        }));
    }

    protected processEnum(response: HttpResponseBase): Observable<CommonEnumDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommonEnumDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonEnumDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ConfigSystemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getlist(body: PagingConfigSystemRequest | undefined): Observable<ConfigSystemDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/config-system/getlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSystemDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSystemDtoPagedResultDto>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<ConfigSystemDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSystemDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSystemDtoPagedResultDto>(null as any);
    }

    /**
     * @return Success
     */
    getbycode(code: string | null): Observable<ConfigSystemDto> {
        let url_ = this.baseUrl + "/api/danh-muc/config-system/getbycode/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbycode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbycode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSystemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSystemDto>;
        }));
    }

    protected processGetbycode(response: HttpResponseBase): Observable<ConfigSystemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSystemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSystemDto>(null as any);
    }

    /**
     * @return Success
     */
    getbyid(id: number): Observable<ConfigSystemDto> {
        let url_ = this.baseUrl + "/api/danh-muc/config-system/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSystemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSystemDto>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<ConfigSystemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSystemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSystemDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: ConfigSystemDto | undefined): Observable<ConfigSystemDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/config-system/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSystemDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSystemDtoCommonResultDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ConfigSystemDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSystemDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSystemDtoCommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(id: number, body: ConfigSystemDto | undefined): Observable<ConfigSystemDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/config-system/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigSystemDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigSystemDtoCommonResultDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ConfigSystemDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigSystemDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigSystemDtoCommonResultDto>(null as any);
    }

    /**
     * @return Success
     */
    removebyid(id: number): Observable<Int64CommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/config-system/removebyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovebyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovebyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64CommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64CommonResultDto>;
        }));
    }

    protected processRemovebyid(response: HttpResponseBase): Observable<Int64CommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64CommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64CommonResultDto>(null as any);
    }

    /**
     * @param isAll (optional) 
     * @param fileType (optional) 
     * @param body (optional) 
     * @return Success
     */
    getlisttofile(isAll: boolean | undefined, fileType: number | undefined, body: PagingConfigSystemRequest | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/danh-muc/config-system/getlisttofile?";
        if (isAll === null)
            throw new Error("The parameter 'isAll' cannot be null.");
        else if (isAll !== undefined)
            url_ += "isAll=" + encodeURIComponent("" + isAll) + "&";
        if (fileType === null)
            throw new Error("The parameter 'fileType' cannot be null.");
        else if (fileType !== undefined)
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlisttofile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlisttofile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetlisttofile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DanhMucHuyenServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkValidImportExcelDanhMucHuyen(body: CheckValidImportExcelDanhMucHuyenRequest | undefined): Observable<CheckValidImportExcelDanhMucHuyenDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-huyen/check-valid-import-excel-danh-muc-huyen";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckValidImportExcelDanhMucHuyen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckValidImportExcelDanhMucHuyen(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckValidImportExcelDanhMucHuyenDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckValidImportExcelDanhMucHuyenDto[]>;
        }));
    }

    protected processCheckValidImportExcelDanhMucHuyen(response: HttpResponseBase): Observable<CheckValidImportExcelDanhMucHuyenDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CheckValidImportExcelDanhMucHuyenDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckValidImportExcelDanhMucHuyenDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadExcelDanhMucHuyen(body: UploadExcelDanhMucHuyenRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-huyen/upload-excel-danh-muc-huyen";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadExcelDanhMucHuyen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadExcelDanhMucHuyen(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadExcelDanhMucHuyen(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportExcelDanhMucHuyen(body: ExportDanhMucHuyenRequest | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-huyen/export-excel-danh-muc-huyen";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelDanhMucHuyen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelDanhMucHuyen(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportExcelDanhMucHuyen(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param updateId (optional) 
     * @return Success
     */
    isIdHuyenExist(id: string | null | undefined, updateId: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-huyen/is-id-huyen-exist?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (updateId !== undefined && updateId !== null)
            url_ += "updateId=" + encodeURIComponent("" + updateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsIdHuyenExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsIdHuyenExist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsIdHuyenExist(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(id: string | null, body: HuyenDto | undefined): Observable<HuyenDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-huyen/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HuyenDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HuyenDtoCommonResultDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<HuyenDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HuyenDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HuyenDtoCommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getlist(body: HuyenPagedRequestDto | undefined): Observable<HuyenDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-huyen/getlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HuyenDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HuyenDtoPagedResultDto>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<HuyenDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HuyenDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HuyenDtoPagedResultDto>(null as any);
    }

    /**
     * @return Success
     */
    getbyid(id: string | null): Observable<HuyenDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-huyen/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HuyenDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HuyenDto>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<HuyenDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HuyenDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HuyenDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: HuyenDto | undefined): Observable<HuyenDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-huyen/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HuyenDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HuyenDtoCommonResultDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<HuyenDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HuyenDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HuyenDtoCommonResultDto>(null as any);
    }

    /**
     * @return Success
     */
    removebyid(id: string | null): Observable<StringCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-huyen/removebyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovebyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovebyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringCommonResultDto>;
        }));
    }

    protected processRemovebyid(response: HttpResponseBase): Observable<StringCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringCommonResultDto>(null as any);
    }

    /**
     * @param isAll (optional) 
     * @param fileType (optional) 
     * @param body (optional) 
     * @return Success
     */
    getlisttofile(isAll: boolean | undefined, fileType: number | undefined, body: HuyenPagedRequestDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-huyen/getlisttofile?";
        if (isAll === null)
            throw new Error("The parameter 'isAll' cannot be null.");
        else if (isAll !== undefined)
            url_ += "isAll=" + encodeURIComponent("" + isAll) + "&";
        if (fileType === null)
            throw new Error("The parameter 'fileType' cannot be null.");
        else if (fileType !== undefined)
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlisttofile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlisttofile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetlisttofile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DanhMucQuocTichServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getlist(body: PagingQuocTichRequest | undefined): Observable<QuocTichDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-quoc-tich/getlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuocTichDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuocTichDtoPagedResultDto>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<QuocTichDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuocTichDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuocTichDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportExcelQuocTich(body: ExportQuocTichRequest | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-quoc-tich/export-excel-quoc-tich";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelQuocTich(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelQuocTich(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportExcelQuocTich(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param updateId (optional) 
     * @return Success
     */
    isIdQuocTichExist(id: string | null | undefined, updateId: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-quoc-tich/is-id-quoc-tich-exist?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (updateId !== undefined && updateId !== null)
            url_ += "updateId=" + encodeURIComponent("" + updateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsIdQuocTichExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsIdQuocTichExist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsIdQuocTichExist(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkValidImportExcelQuocTich(body: CheckValidImportExcelQuocTichRequest | undefined): Observable<CheckValidImportExcelQuocTichDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-quoc-tich/check-valid-import-excel-quoc-tich";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckValidImportExcelQuocTich(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckValidImportExcelQuocTich(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckValidImportExcelQuocTichDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckValidImportExcelQuocTichDto[]>;
        }));
    }

    protected processCheckValidImportExcelQuocTich(response: HttpResponseBase): Observable<CheckValidImportExcelQuocTichDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CheckValidImportExcelQuocTichDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckValidImportExcelQuocTichDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadExcelQuocTich(body: UploadExcelQuocGiaRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-quoc-tich/upload-excel-quoc-tich";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadExcelQuocTich(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadExcelQuocTich(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadExcelQuocTich(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getbyid(id: string | null): Observable<QuocTichDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-quoc-tich/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuocTichDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuocTichDto>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<QuocTichDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuocTichDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuocTichDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: QuocTichDto | undefined): Observable<QuocTichDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-quoc-tich/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuocTichDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuocTichDtoCommonResultDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<QuocTichDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuocTichDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuocTichDtoCommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(id: string | null, body: QuocTichDto | undefined): Observable<QuocTichDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-quoc-tich/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QuocTichDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QuocTichDtoCommonResultDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<QuocTichDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuocTichDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuocTichDtoCommonResultDto>(null as any);
    }

    /**
     * @return Success
     */
    removebyid(id: string | null): Observable<StringCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-quoc-tich/removebyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovebyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovebyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringCommonResultDto>;
        }));
    }

    protected processRemovebyid(response: HttpResponseBase): Observable<StringCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringCommonResultDto>(null as any);
    }

    /**
     * @param isAll (optional) 
     * @param fileType (optional) 
     * @param body (optional) 
     * @return Success
     */
    getlisttofile(isAll: boolean | undefined, fileType: number | undefined, body: PagingQuocTichRequest | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-quoc-tich/getlisttofile?";
        if (isAll === null)
            throw new Error("The parameter 'isAll' cannot be null.");
        else if (isAll !== undefined)
            url_ += "isAll=" + encodeURIComponent("" + isAll) + "&";
        if (fileType === null)
            throw new Error("The parameter 'fileType' cannot be null.");
        else if (fileType !== undefined)
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlisttofile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlisttofile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetlisttofile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DanhMucTinhServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getMyTest(input: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh/get-my-test?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetMyTest(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param id (optional) 
     * @param updateId (optional) 
     * @return Success
     */
    isIdTinhExist(id: string | null | undefined, updateId: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh/is-id-tinh-exist?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (updateId !== undefined && updateId !== null)
            url_ += "updateId=" + encodeURIComponent("" + updateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsIdTinhExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsIdTinhExist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsIdTinhExist(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param ma (optional) 
     * @param updateMa (optional) 
     * @return Success
     */
    isMaTinhExist(ma: string | null | undefined, updateMa: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh/is-ma-tinh-exist?";
        if (ma !== undefined && ma !== null)
            url_ += "ma=" + encodeURIComponent("" + ma) + "&";
        if (updateMa !== undefined && updateMa !== null)
            url_ += "updateMa=" + encodeURIComponent("" + updateMa) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsMaTinhExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsMaTinhExist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsMaTinhExist(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(id: string | null, body: TinhDto | undefined): Observable<TinhDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TinhDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TinhDtoCommonResultDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TinhDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TinhDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinhDtoCommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkValidImportExcelDanhMucTinh(body: CheckValidImportExcelDanhMucTinhRequest | undefined): Observable<CheckValidImportExcelDanhMucTinhDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh/check-valid-import-excel-danh-muc-tinh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckValidImportExcelDanhMucTinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckValidImportExcelDanhMucTinh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckValidImportExcelDanhMucTinhDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckValidImportExcelDanhMucTinhDto[]>;
        }));
    }

    protected processCheckValidImportExcelDanhMucTinh(response: HttpResponseBase): Observable<CheckValidImportExcelDanhMucTinhDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CheckValidImportExcelDanhMucTinhDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckValidImportExcelDanhMucTinhDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadExcelDanhMucTinh(body: UploadExcelDanhMucTinhRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh/upload-excel-danh-muc-tinh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadExcelDanhMucTinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadExcelDanhMucTinh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadExcelDanhMucTinh(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportExcelDanhMucTinh(body: ExportDanhMucTinhRequest | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh/export-excel-danh-muc-tinh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelDanhMucTinh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelDanhMucTinh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportExcelDanhMucTinh(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param check (optional) 
     * @param maTinh (optional) 
     * @return Success
     */
    changeTinhGan(check: boolean | undefined, maTinh: string | null | undefined): Observable<BooleanCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh/change-tinh-gan?";
        if (check === null)
            throw new Error("The parameter 'check' cannot be null.");
        else if (check !== undefined)
            url_ += "check=" + encodeURIComponent("" + check) + "&";
        if (maTinh !== undefined && maTinh !== null)
            url_ += "maTinh=" + encodeURIComponent("" + maTinh) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeTinhGan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeTinhGan(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanCommonResultDto>;
        }));
    }

    protected processChangeTinhGan(response: HttpResponseBase): Observable<BooleanCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanCommonResultDto>(null as any);
    }

    /**
     * @return Success
     */
    all(): Observable<BooleanCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanCommonResultDto>;
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<BooleanCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanCommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getlist(body: TinhPagedRequestDto | undefined): Observable<TinhDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh/getlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TinhDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TinhDtoPagedResultDto>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<TinhDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TinhDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinhDtoPagedResultDto>(null as any);
    }

    /**
     * @return Success
     */
    getbyid(id: string | null): Observable<TinhDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TinhDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TinhDto>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<TinhDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TinhDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinhDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: TinhDto | undefined): Observable<TinhDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TinhDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TinhDtoCommonResultDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TinhDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TinhDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinhDtoCommonResultDto>(null as any);
    }

    /**
     * @return Success
     */
    removebyid(id: string | null): Observable<StringCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh/removebyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovebyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovebyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringCommonResultDto>;
        }));
    }

    protected processRemovebyid(response: HttpResponseBase): Observable<StringCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringCommonResultDto>(null as any);
    }

    /**
     * @param isAll (optional) 
     * @param fileType (optional) 
     * @param body (optional) 
     * @return Success
     */
    getlisttofile(isAll: boolean | undefined, fileType: number | undefined, body: TinhPagedRequestDto | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-tinh/getlisttofile?";
        if (isAll === null)
            throw new Error("The parameter 'isAll' cannot be null.");
        else if (isAll !== undefined)
            url_ += "isAll=" + encodeURIComponent("" + isAll) + "&";
        if (fileType === null)
            throw new Error("The parameter 'fileType' cannot be null.");
        else if (fileType !== undefined)
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlisttofile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlisttofile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetlisttofile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DanhMucXaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getlist(body: PagingXaRequest | undefined): Observable<XaDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-xa/getlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XaDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XaDtoPagedResultDto>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<XaDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = XaDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XaDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param updateId (optional) 
     * @return Success
     */
    isIdXaExist(id: string | null | undefined, updateId: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-xa/is-id-xa-exist?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (updateId !== undefined && updateId !== null)
            url_ += "updateId=" + encodeURIComponent("" + updateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsIdXaExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsIdXaExist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsIdXaExist(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkValidImportExcelNhomThucPham(body: CheckValidImportExcelXaRequest | undefined): Observable<CheckValidImportExcelXaDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-xa/check-valid-import-excel-nhom-thuc-pham";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckValidImportExcelNhomThucPham(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckValidImportExcelNhomThucPham(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckValidImportExcelXaDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckValidImportExcelXaDto[]>;
        }));
    }

    protected processCheckValidImportExcelNhomThucPham(response: HttpResponseBase): Observable<CheckValidImportExcelXaDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CheckValidImportExcelXaDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckValidImportExcelXaDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadExcelXa(body: UploadExcelXaRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-xa/upload-excel-xa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadExcelXa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadExcelXa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadExcelXa(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportExcelXa(body: ExportXaRequest | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-xa/export-excel-xa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelXa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelXa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportExcelXa(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(id: string | null, body: XaDto | undefined): Observable<XaDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-xa/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XaDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XaDtoCommonResultDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<XaDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = XaDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XaDtoCommonResultDto>(null as any);
    }

    /**
     * @return Success
     */
    getbyid(id: string | null): Observable<XaDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-xa/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XaDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XaDto>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<XaDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = XaDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XaDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: XaDto | undefined): Observable<XaDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-xa/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<XaDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<XaDtoCommonResultDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<XaDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = XaDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XaDtoCommonResultDto>(null as any);
    }

    /**
     * @return Success
     */
    removebyid(id: string | null): Observable<StringCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-xa/removebyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovebyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovebyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringCommonResultDto>;
        }));
    }

    protected processRemovebyid(response: HttpResponseBase): Observable<StringCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringCommonResultDto>(null as any);
    }

    /**
     * @param isAll (optional) 
     * @param fileType (optional) 
     * @param body (optional) 
     * @return Success
     */
    getlisttofile(isAll: boolean | undefined, fileType: number | undefined, body: PagingXaRequest | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/danh-muc/danh-muc-xa/getlisttofile?";
        if (isAll === null)
            throw new Error("The parameter 'isAll' cannot be null.");
        else if (isAll !== undefined)
            url_ += "isAll=" + encodeURIComponent("" + isAll) + "&";
        if (fileType === null)
            throw new Error("The parameter 'fileType' cannot be null.");
        else if (fileType !== undefined)
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlisttofile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlisttofile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetlisttofile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DichVuPhongServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paginglisthangphong(body: PagingListHangPhongRequest | undefined): Observable<DichVuHangPhongDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/dich-vu-phong/paginglisthangphong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaginglisthangphong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaginglisthangphong(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DichVuHangPhongDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DichVuHangPhongDtoPagedResultDto>;
        }));
    }

    protected processPaginglisthangphong(response: HttpResponseBase): Observable<DichVuHangPhongDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DichVuHangPhongDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DichVuHangPhongDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createorupdatehangphong(body: CreateOrUpdateHangPhongRequest | undefined): Observable<Int64CommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/dich-vu-phong/createorupdatehangphong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdatehangphong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdatehangphong(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64CommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64CommonResultDto>;
        }));
    }

    protected processCreateorupdatehangphong(response: HttpResponseBase): Observable<Int64CommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64CommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64CommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getlistgiaphong(body: PagingListGiaPhongRequest | undefined): Observable<DichVuGiaPhongDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/dich-vu-phong/getlistgiaphong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlistgiaphong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlistgiaphong(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DichVuGiaPhongDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DichVuGiaPhongDtoPagedResultDto>;
        }));
    }

    protected processGetlistgiaphong(response: HttpResponseBase): Observable<DichVuGiaPhongDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DichVuGiaPhongDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DichVuGiaPhongDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createorupdatedichvugiaphong(body: CreateOrUpdateDichVuGiaPhongRequest | undefined): Observable<Int64CommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/dich-vu-phong/createorupdatedichvugiaphong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdatedichvugiaphong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdatedichvugiaphong(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64CommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64CommonResultDto>;
        }));
    }

    protected processCreateorupdatedichvugiaphong(response: HttpResponseBase): Observable<Int64CommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64CommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64CommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getcomboboxhangphong(body: GetComboboxHangPhongRequest | undefined): Observable<ComboBoxDtoListCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/dich-vu-phong/getcomboboxhangphong";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcomboboxhangphong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcomboboxhangphong(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboBoxDtoListCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboBoxDtoListCommonResultDto>;
        }));
    }

    protected processGetcomboboxhangphong(response: HttpResponseBase): Observable<ComboBoxDtoListCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ComboBoxDtoListCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboBoxDtoListCommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    gethangphongbyid(body: GetHangPhongByIdRequest | undefined): Observable<DichVuHangPhongDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/dich-vu-phong/gethangphongbyid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGethangphongbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGethangphongbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DichVuHangPhongDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DichVuHangPhongDtoCommonResultDto>;
        }));
    }

    protected processGethangphongbyid(response: HttpResponseBase): Observable<DichVuHangPhongDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DichVuHangPhongDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DichVuHangPhongDtoCommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getgiaphongbyid(body: GetGiaPhongByIdRequest | undefined): Observable<DichVuGiaPhongDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/dich-vu-phong/getgiaphongbyid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetgiaphongbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetgiaphongbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DichVuGiaPhongDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DichVuGiaPhongDtoCommonResultDto>;
        }));
    }

    protected processGetgiaphongbyid(response: HttpResponseBase): Observable<DichVuGiaPhongDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DichVuGiaPhongDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DichVuGiaPhongDtoCommonResultDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DichVuVeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paginglist(body: PagingListDichVuVeRequest | undefined): Observable<DichVuVeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/dich-vu-ve/paginglist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaginglist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaginglist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DichVuVeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DichVuVeDtoPagedResultDto>;
        }));
    }

    protected processPaginglist(response: HttpResponseBase): Observable<DichVuVeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DichVuVeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DichVuVeDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createorupdate(body: CreateOrUpdateDichVuVeRequest | undefined): Observable<Int64CommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/dich-vu-ve/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64CommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64CommonResultDto>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<Int64CommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64CommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64CommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getbyid(body: GetDichVuVeByIdRequest | undefined): Observable<DichVuVeDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/dich-vu-ve/getbyid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DichVuVeDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DichVuVeDtoCommonResultDto>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<DichVuVeDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DichVuVeDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DichVuVeDtoCommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getnhacungcapdichvuve(body: GetNhaCungCapDichVuVeRequest | undefined): Observable<NhaCungCapDichVuVeDtoListCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/dich-vu-ve/getnhacungcapdichvuve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetnhacungcapdichvuve(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetnhacungcapdichvuve(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NhaCungCapDichVuVeDtoListCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NhaCungCapDichVuVeDtoListCommonResultDto>;
        }));
    }

    protected processGetnhacungcapdichvuve(response: HttpResponseBase): Observable<NhaCungCapDichVuVeDtoListCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhaCungCapDichVuVeDtoListCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhaCungCapDichVuVeDtoListCommonResultDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DichVuXeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paginglist(body: PagingListDichVuXeRequest | undefined): Observable<DichVuXeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/dich-vu-xe/paginglist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaginglist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaginglist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DichVuXeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DichVuXeDtoPagedResultDto>;
        }));
    }

    protected processPaginglist(response: HttpResponseBase): Observable<DichVuXeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DichVuXeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DichVuXeDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createorupdate(body: CreateOrUpdateDichVuXeRequest | undefined): Observable<Int64CommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/dich-vu-xe/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64CommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64CommonResultDto>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<Int64CommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64CommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64CommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getbyid(body: GetDichVuXeByIdRequest | undefined): Observable<DichVuXeDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/dich-vu-xe/getbyid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DichVuXeDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DichVuXeDtoCommonResultDto>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<DichVuXeDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DichVuXeDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DichVuXeDtoCommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getnhacungcapdichvuxe(body: GetNhaCungCapDichVuXeRequest | undefined): Observable<NhaCungCapDichVuXeDtoListCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/dich-vu-xe/getnhacungcapdichvuxe";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetnhacungcapdichvuxe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetnhacungcapdichvuxe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NhaCungCapDichVuXeDtoListCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NhaCungCapDichVuXeDtoListCommonResultDto>;
        }));
    }

    protected processGetnhacungcapdichvuxe(response: HttpResponseBase): Observable<NhaCungCapDichVuXeDtoListCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhaCungCapDichVuXeDtoListCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhaCungCapDichVuXeDtoListCommonResultDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class FileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    downloadtempfile(token: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/file/downloadtempfile/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadtempfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadtempfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDownloadtempfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param width (optional) 
     * @param height (optional) 
     * @return Success
     */
    uploadanh(width: number | null | undefined, height: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/danh-muc/file/uploadanh?";
        if (width !== undefined && width !== null)
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height !== undefined && height !== null)
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadanh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadanh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processUploadanh(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }

    /**
     * @return Success
     */
    gotoview(token: string | null): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/file/gotoview/{token}";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGotoview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGotoview(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGotoview(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param imgName (optional) 
     * @param blobContainer (optional) 
     * @param contentType (optional) 
     * @return Success
     */
    gotoviewimage(imgName: string | null | undefined, blobContainer: string | null | undefined, contentType: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/file/gotoviewimage?";
        if (imgName !== undefined && imgName !== null)
            url_ += "imgName=" + encodeURIComponent("" + imgName) + "&";
        if (blobContainer !== undefined && blobContainer !== null)
            url_ += "blobContainer=" + encodeURIComponent("" + blobContainer) + "&";
        if (contentType !== undefined && contentType !== null)
            url_ += "contentType=" + encodeURIComponent("" + contentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGotoviewimage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGotoviewimage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGotoviewimage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param url (optional) 
     * @return Success
     */
    taitepdinhkem(url: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/file/taitepdinhkem?";
        if (url !== undefined && url !== null)
            url_ += "url=" + encodeURIComponent("" + url) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTaitepdinhkem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTaitepdinhkem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTaitepdinhkem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UploadlogoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    nhacungcap(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/file/uploadlogo/nhacungcap/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNhacungcap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNhacungcap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processNhacungcap(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class HopDongNccServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paginglisthopdongncc(body: PagingListHopDongNCCRequest | undefined): Observable<HopDongNCCDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/hop-dong-ncc/paginglisthopdongncc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaginglisthopdongncc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaginglisthopdongncc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HopDongNCCDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HopDongNCCDtoPagedResultDto>;
        }));
    }

    protected processPaginglisthopdongncc(response: HttpResponseBase): Observable<HopDongNCCDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HopDongNCCDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HopDongNCCDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createorupdatehopdongncc(body: CreateOrUpdateHopDongNCCRequest | undefined): Observable<Int64CommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/hop-dong-ncc/createorupdatehopdongncc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdatehopdongncc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdatehopdongncc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64CommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64CommonResultDto>;
        }));
    }

    protected processCreateorupdatehopdongncc(response: HttpResponseBase): Observable<Int64CommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64CommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64CommonResultDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class NguoiLienHeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paginglist(body: PagingListNguoiLienHeRequest | undefined): Observable<NguoiLienHeNCCDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/nguoi-lien-he/paginglist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaginglist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaginglist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NguoiLienHeNCCDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NguoiLienHeNCCDtoPagedResultDto>;
        }));
    }

    protected processPaginglist(response: HttpResponseBase): Observable<NguoiLienHeNCCDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NguoiLienHeNCCDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NguoiLienHeNCCDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createorupdate(body: CreateOrUpdateNguoiLienHeNCCRequest | undefined): Observable<Int64CommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/nguoi-lien-he/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64CommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64CommonResultDto>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<Int64CommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64CommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64CommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getbyid(body: GetNguoiLienByIdRequest | undefined): Observable<NguoiLienHeNCCDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/nguoi-lien-he/getbyid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NguoiLienHeNCCDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NguoiLienHeNCCDtoCommonResultDto>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<NguoiLienHeNCCDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NguoiLienHeNCCDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NguoiLienHeNCCDtoCommonResultDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class NhaCungCapServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getlist(body: PagingNhaCungCapRequest | undefined): Observable<NhaCungCapDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/nha-cung-cap/getlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NhaCungCapDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NhaCungCapDtoPagedResultDto>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<NhaCungCapDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhaCungCapDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhaCungCapDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertorupdatenhacungcap(body: InsertOrUpdateNhaCungCapRequest | undefined): Observable<BooleanCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/nha-cung-cap/insertorupdatenhacungcap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertorupdatenhacungcap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertorupdatenhacungcap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanCommonResultDto>;
        }));
    }

    protected processInsertorupdatenhacungcap(response: HttpResponseBase): Observable<BooleanCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooleanCommonResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<CommResultErrorDto> {
        let url_ = this.baseUrl + "/api/danh-muc/nha-cung-cap/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommResultErrorDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommResultErrorDto>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<CommResultErrorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommResultErrorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommResultErrorDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportNhaCungCap(body: ExportExcelNhaCungCapRequest | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/danh-muc/nha-cung-cap/export-nha-cung-cap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportNhaCungCap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportNhaCungCap(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processExportNhaCungCap(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class NhaCungCapKhachSanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paginglist(body: PagingListNhaCungCapKhachSanRequest | undefined): Observable<NhaCungCapKhachSanDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/nha-cung-cap-khach-san/paginglist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaginglist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaginglist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NhaCungCapKhachSanDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NhaCungCapKhachSanDtoPagedResultDto>;
        }));
    }

    protected processPaginglist(response: HttpResponseBase): Observable<NhaCungCapKhachSanDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhaCungCapKhachSanDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhaCungCapKhachSanDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createorupdate(body: CreateOrUpdateNhaCungCapKhachSanRequest | undefined): Observable<Int64CommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/nha-cung-cap-khach-san/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64CommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64CommonResultDto>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<Int64CommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64CommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64CommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    viewdetail(body: ViewDetailNhaCungCapKhachSanRequest | undefined): Observable<NhaCungCapKhachSanDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/nha-cung-cap-khach-san/viewdetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processViewdetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViewdetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NhaCungCapKhachSanDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NhaCungCapKhachSanDtoCommonResultDto>;
        }));
    }

    protected processViewdetail(response: HttpResponseBase): Observable<NhaCungCapKhachSanDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhaCungCapKhachSanDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhaCungCapKhachSanDtoCommonResultDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class NhaCungCapVeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paginglist(body: PagingListNhaCungCapVeRequest | undefined): Observable<NhaCungCapVeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/nha-cung-cap-ve/paginglist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaginglist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaginglist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NhaCungCapVeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NhaCungCapVeDtoPagedResultDto>;
        }));
    }

    protected processPaginglist(response: HttpResponseBase): Observable<NhaCungCapVeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhaCungCapVeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhaCungCapVeDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createorupdate(body: CreateOrUpdateNhaCungCapVeRequest | undefined): Observable<Int64CommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/nha-cung-cap-ve/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64CommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64CommonResultDto>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<Int64CommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64CommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64CommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getbyid(body: GetNCCVeByIdRequest | undefined): Observable<NhaCungCapVeDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/nha-cung-cap-ve/getbyid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NhaCungCapVeDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NhaCungCapVeDtoCommonResultDto>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<NhaCungCapVeDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhaCungCapVeDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhaCungCapVeDtoCommonResultDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class NhaCungCapXeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paginglist(body: PagingListNhaCungCapXeRequest | undefined): Observable<NhaCungCapXeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/nha-cung-cap-xe/paginglist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaginglist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaginglist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NhaCungCapXeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NhaCungCapXeDtoPagedResultDto>;
        }));
    }

    protected processPaginglist(response: HttpResponseBase): Observable<NhaCungCapXeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhaCungCapXeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhaCungCapXeDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createorupdate(body: CreateOrUpdateNhaCungCapXeRequest | undefined): Observable<Int64CommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/nha-cung-cap-xe/createorupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorupdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorupdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64CommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64CommonResultDto>;
        }));
    }

    protected processCreateorupdate(response: HttpResponseBase): Observable<Int64CommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64CommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64CommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getbyid(body: GetNCCXeByIdRequest | undefined): Observable<NhaCungCapXeDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/nha-cung-cap-xe/getbyid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NhaCungCapXeDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NhaCungCapXeDtoCommonResultDto>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<NhaCungCapXeDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NhaCungCapXeDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NhaCungCapXeDtoCommonResultDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrdApplicationConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<ApplicationConfigurationDto> {
        let url_ = this.baseUrl + "/api/danh-muc/ord-application-configuration/get-configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicationConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicationConfigurationDto>;
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<ApplicationConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationConfigurationDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TepDinhKemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getlist(body: PagingTepDinhKemRequest | undefined): Observable<TepDinhKemDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/tep-dinh-kem/getlist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TepDinhKemDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TepDinhKemDtoPagedResultDto>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<TepDinhKemDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TepDinhKemDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TepDinhKemDtoPagedResultDto>(null as any);
    }

    /**
     * @param idDanhMuc (optional) 
     * @param loaiDanhMuc (optional) 
     * @return Success
     */
    tepDinhKemByIdDanhMuc(idDanhMuc: number | undefined, loaiDanhMuc: number | undefined): Observable<TepDinhKemDto[]> {
        let url_ = this.baseUrl + "/api/danh-muc/tep-dinh-kem/tep-dinh-kem-by-id-danh-muc?";
        if (idDanhMuc === null)
            throw new Error("The parameter 'idDanhMuc' cannot be null.");
        else if (idDanhMuc !== undefined)
            url_ += "IdDanhMuc=" + encodeURIComponent("" + idDanhMuc) + "&";
        if (loaiDanhMuc === null)
            throw new Error("The parameter 'loaiDanhMuc' cannot be null.");
        else if (loaiDanhMuc !== undefined)
            url_ += "LoaiDanhMuc=" + encodeURIComponent("" + loaiDanhMuc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTepDinhKemByIdDanhMuc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTepDinhKemByIdDanhMuc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TepDinhKemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TepDinhKemDto[]>;
        }));
    }

    protected processTepDinhKemByIdDanhMuc(response: HttpResponseBase): Observable<TepDinhKemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TepDinhKemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TepDinhKemDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getbyid(id: number): Observable<TepDinhKemDto> {
        let url_ = this.baseUrl + "/api/danh-muc/tep-dinh-kem/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TepDinhKemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TepDinhKemDto>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<TepDinhKemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TepDinhKemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TepDinhKemDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: TepDinhKemDto | undefined): Observable<TepDinhKemDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/tep-dinh-kem/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TepDinhKemDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TepDinhKemDtoCommonResultDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TepDinhKemDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TepDinhKemDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TepDinhKemDtoCommonResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(id: number, body: TepDinhKemDto | undefined): Observable<TepDinhKemDtoCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/tep-dinh-kem/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TepDinhKemDtoCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TepDinhKemDtoCommonResultDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TepDinhKemDtoCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TepDinhKemDtoCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TepDinhKemDtoCommonResultDto>(null as any);
    }

    /**
     * @return Success
     */
    removebyid(id: number): Observable<Int64CommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/tep-dinh-kem/removebyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovebyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovebyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Int64CommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Int64CommonResultDto>;
        }));
    }

    protected processRemovebyid(response: HttpResponseBase): Observable<Int64CommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64CommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64CommonResultDto>(null as any);
    }

    /**
     * @param isAll (optional) 
     * @param fileType (optional) 
     * @param body (optional) 
     * @return Success
     */
    getlisttofile(isAll: boolean | undefined, fileType: number | undefined, body: PagingTepDinhKemRequest | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/danh-muc/tep-dinh-kem/getlisttofile?";
        if (isAll === null)
            throw new Error("The parameter 'isAll' cannot be null.");
        else if (isAll !== undefined)
            url_ += "isAll=" + encodeURIComponent("" + isAll) + "&";
        if (fileType === null)
            throw new Error("The parameter 'fileType' cannot be null.");
        else if (fileType !== undefined)
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlisttofile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlisttofile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetlisttofile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ThanhToanServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    payment(body: CreatePaymentVNPayRequest | undefined): Observable<StringCommonResultDto> {
        let url_ = this.baseUrl + "/api/danh-muc/thanh-toan/payment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringCommonResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringCommonResultDto>;
        }));
    }

    protected processPayment(response: HttpResponseBase): Observable<StringCommonResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringCommonResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringCommonResultDto>(null as any);
    }

    paymentexecute(): Observable<void> {
        let url_ = this.baseUrl + "/api/danh-muc/thanh-toan/paymentexecute";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentexecute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentexecute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPaymentexecute(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = RemoteServiceErrorResponse.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = RemoteServiceErrorResponse.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = RemoteServiceErrorResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = RemoteServiceErrorResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 501) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result501: any = null;
            let resultData501 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result501 = RemoteServiceErrorResponse.fromJS(resultData501);
            return throwException("Server Error", status, _responseText, _headers, result501);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = RemoteServiceErrorResponse.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export class ControllerInterfaceApiDescriptionModel implements IControllerInterfaceApiDescriptionModel {
    type!: string | undefined;

    constructor(data?: IControllerInterfaceApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ControllerInterfaceApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerInterfaceApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        return data;
    }
}

export interface IControllerInterfaceApiDescriptionModel {
    type: string | undefined;
}

export class MethodParameterApiDescriptionModel implements IMethodParameterApiDescriptionModel {
    name!: string | undefined;
    typeAsString!: string | undefined;
    type!: string | undefined;
    typeSimple!: string | undefined;
    isOptional!: boolean;
    defaultValue!: any | undefined;

    constructor(data?: IMethodParameterApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.typeAsString = _data["typeAsString"];
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.isOptional = _data["isOptional"];
            this.defaultValue = _data["defaultValue"];
        }
    }

    static fromJS(data: any): MethodParameterApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new MethodParameterApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["typeAsString"] = this.typeAsString;
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["isOptional"] = this.isOptional;
        data["defaultValue"] = this.defaultValue;
        return data;
    }
}

export interface IMethodParameterApiDescriptionModel {
    name: string | undefined;
    typeAsString: string | undefined;
    type: string | undefined;
    typeSimple: string | undefined;
    isOptional: boolean;
    defaultValue: any | undefined;
}

export class ParameterApiDescriptionModel implements IParameterApiDescriptionModel {
    nameOnMethod!: string | undefined;
    name!: string | undefined;
    jsonName!: string | undefined;
    type!: string | undefined;
    typeSimple!: string | undefined;
    isOptional!: boolean;
    defaultValue!: any | undefined;
    constraintTypes!: string[] | undefined;
    bindingSourceId!: string | undefined;
    descriptorName!: string | undefined;

    constructor(data?: IParameterApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameOnMethod = _data["nameOnMethod"];
            this.name = _data["name"];
            this.jsonName = _data["jsonName"];
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.isOptional = _data["isOptional"];
            this.defaultValue = _data["defaultValue"];
            if (Array.isArray(_data["constraintTypes"])) {
                this.constraintTypes = [] as any;
                for (let item of _data["constraintTypes"])
                    this.constraintTypes!.push(item);
            }
            this.bindingSourceId = _data["bindingSourceId"];
            this.descriptorName = _data["descriptorName"];
        }
    }

    static fromJS(data: any): ParameterApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameOnMethod"] = this.nameOnMethod;
        data["name"] = this.name;
        data["jsonName"] = this.jsonName;
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["isOptional"] = this.isOptional;
        data["defaultValue"] = this.defaultValue;
        if (Array.isArray(this.constraintTypes)) {
            data["constraintTypes"] = [];
            for (let item of this.constraintTypes)
                data["constraintTypes"].push(item);
        }
        data["bindingSourceId"] = this.bindingSourceId;
        data["descriptorName"] = this.descriptorName;
        return data;
    }
}

export interface IParameterApiDescriptionModel {
    nameOnMethod: string | undefined;
    name: string | undefined;
    jsonName: string | undefined;
    type: string | undefined;
    typeSimple: string | undefined;
    isOptional: boolean;
    defaultValue: any | undefined;
    constraintTypes: string[] | undefined;
    bindingSourceId: string | undefined;
    descriptorName: string | undefined;
}

export class ReturnValueApiDescriptionModel implements IReturnValueApiDescriptionModel {
    type!: string | undefined;
    typeSimple!: string | undefined;

    constructor(data?: IReturnValueApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
        }
    }

    static fromJS(data: any): ReturnValueApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnValueApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        return data;
    }
}

export interface IReturnValueApiDescriptionModel {
    type: string | undefined;
    typeSimple: string | undefined;
}

export class ActionApiDescriptionModel implements IActionApiDescriptionModel {
    uniqueName!: string | undefined;
    name!: string | undefined;
    httpMethod!: string | undefined;
    url!: string | undefined;
    supportedVersions!: string[] | undefined;
    parametersOnMethod!: MethodParameterApiDescriptionModel[] | undefined;
    parameters!: ParameterApiDescriptionModel[] | undefined;
    returnValue!: ReturnValueApiDescriptionModel;

    constructor(data?: IActionApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uniqueName = _data["uniqueName"];
            this.name = _data["name"];
            this.httpMethod = _data["httpMethod"];
            this.url = _data["url"];
            if (Array.isArray(_data["supportedVersions"])) {
                this.supportedVersions = [] as any;
                for (let item of _data["supportedVersions"])
                    this.supportedVersions!.push(item);
            }
            if (Array.isArray(_data["parametersOnMethod"])) {
                this.parametersOnMethod = [] as any;
                for (let item of _data["parametersOnMethod"])
                    this.parametersOnMethod!.push(MethodParameterApiDescriptionModel.fromJS(item));
            }
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(ParameterApiDescriptionModel.fromJS(item));
            }
            this.returnValue = _data["returnValue"] ? ReturnValueApiDescriptionModel.fromJS(_data["returnValue"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActionApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActionApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniqueName"] = this.uniqueName;
        data["name"] = this.name;
        data["httpMethod"] = this.httpMethod;
        data["url"] = this.url;
        if (Array.isArray(this.supportedVersions)) {
            data["supportedVersions"] = [];
            for (let item of this.supportedVersions)
                data["supportedVersions"].push(item);
        }
        if (Array.isArray(this.parametersOnMethod)) {
            data["parametersOnMethod"] = [];
            for (let item of this.parametersOnMethod)
                data["parametersOnMethod"].push(item.toJSON());
        }
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        data["returnValue"] = this.returnValue ? this.returnValue.toJSON() : <any>undefined;
        return data;
    }
}

export interface IActionApiDescriptionModel {
    uniqueName: string | undefined;
    name: string | undefined;
    httpMethod: string | undefined;
    url: string | undefined;
    supportedVersions: string[] | undefined;
    parametersOnMethod: MethodParameterApiDescriptionModel[] | undefined;
    parameters: ParameterApiDescriptionModel[] | undefined;
    returnValue: ReturnValueApiDescriptionModel;
}

export class ControllerApiDescriptionModel implements IControllerApiDescriptionModel {
    controllerName!: string | undefined;
    type!: string | undefined;
    interfaces!: ControllerInterfaceApiDescriptionModel[] | undefined;
    actions!: { [key: string]: ActionApiDescriptionModel; } | undefined;

    constructor(data?: IControllerApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.controllerName = _data["controllerName"];
            this.type = _data["type"];
            if (Array.isArray(_data["interfaces"])) {
                this.interfaces = [] as any;
                for (let item of _data["interfaces"])
                    this.interfaces!.push(ControllerInterfaceApiDescriptionModel.fromJS(item));
            }
            if (_data["actions"]) {
                this.actions = {} as any;
                for (let key in _data["actions"]) {
                    if (_data["actions"].hasOwnProperty(key))
                        (<any>this.actions)![key] = _data["actions"][key] ? ActionApiDescriptionModel.fromJS(_data["actions"][key]) : new ActionApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ControllerApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["controllerName"] = this.controllerName;
        data["type"] = this.type;
        if (Array.isArray(this.interfaces)) {
            data["interfaces"] = [];
            for (let item of this.interfaces)
                data["interfaces"].push(item.toJSON());
        }
        if (this.actions) {
            data["actions"] = {};
            for (let key in this.actions) {
                if (this.actions.hasOwnProperty(key))
                    (<any>data["actions"])[key] = this.actions[key] ? this.actions[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IControllerApiDescriptionModel {
    controllerName: string | undefined;
    type: string | undefined;
    interfaces: ControllerInterfaceApiDescriptionModel[] | undefined;
    actions: { [key: string]: ActionApiDescriptionModel; } | undefined;
}

export class ModuleApiDescriptionModel implements IModuleApiDescriptionModel {
    rootPath!: string | undefined;
    remoteServiceName!: string | undefined;
    controllers!: { [key: string]: ControllerApiDescriptionModel; } | undefined;

    constructor(data?: IModuleApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rootPath = _data["rootPath"];
            this.remoteServiceName = _data["remoteServiceName"];
            if (_data["controllers"]) {
                this.controllers = {} as any;
                for (let key in _data["controllers"]) {
                    if (_data["controllers"].hasOwnProperty(key))
                        (<any>this.controllers)![key] = _data["controllers"][key] ? ControllerApiDescriptionModel.fromJS(_data["controllers"][key]) : new ControllerApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ModuleApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rootPath"] = this.rootPath;
        data["remoteServiceName"] = this.remoteServiceName;
        if (this.controllers) {
            data["controllers"] = {};
            for (let key in this.controllers) {
                if (this.controllers.hasOwnProperty(key))
                    (<any>data["controllers"])[key] = this.controllers[key] ? this.controllers[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IModuleApiDescriptionModel {
    rootPath: string | undefined;
    remoteServiceName: string | undefined;
    controllers: { [key: string]: ControllerApiDescriptionModel; } | undefined;
}

export class PropertyApiDescriptionModel implements IPropertyApiDescriptionModel {
    name!: string | undefined;
    jsonName!: string | undefined;
    type!: string | undefined;
    typeSimple!: string | undefined;
    isRequired!: boolean;

    constructor(data?: IPropertyApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.jsonName = _data["jsonName"];
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.isRequired = _data["isRequired"];
        }
    }

    static fromJS(data: any): PropertyApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["jsonName"] = this.jsonName;
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["isRequired"] = this.isRequired;
        return data;
    }
}

export interface IPropertyApiDescriptionModel {
    name: string | undefined;
    jsonName: string | undefined;
    type: string | undefined;
    typeSimple: string | undefined;
    isRequired: boolean;
}

export class TypeApiDescriptionModel implements ITypeApiDescriptionModel {
    baseType!: string | undefined;
    isEnum!: boolean;
    enumNames!: string[] | undefined;
    enumValues!: any[] | undefined;
    genericArguments!: string[] | undefined;
    properties!: PropertyApiDescriptionModel[] | undefined;

    constructor(data?: ITypeApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseType = _data["baseType"];
            this.isEnum = _data["isEnum"];
            if (Array.isArray(_data["enumNames"])) {
                this.enumNames = [] as any;
                for (let item of _data["enumNames"])
                    this.enumNames!.push(item);
            }
            if (Array.isArray(_data["enumValues"])) {
                this.enumValues = [] as any;
                for (let item of _data["enumValues"])
                    this.enumValues!.push(item);
            }
            if (Array.isArray(_data["genericArguments"])) {
                this.genericArguments = [] as any;
                for (let item of _data["genericArguments"])
                    this.genericArguments!.push(item);
            }
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(PropertyApiDescriptionModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TypeApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new TypeApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseType"] = this.baseType;
        data["isEnum"] = this.isEnum;
        if (Array.isArray(this.enumNames)) {
            data["enumNames"] = [];
            for (let item of this.enumNames)
                data["enumNames"].push(item);
        }
        if (Array.isArray(this.enumValues)) {
            data["enumValues"] = [];
            for (let item of this.enumValues)
                data["enumValues"].push(item);
        }
        if (Array.isArray(this.genericArguments)) {
            data["genericArguments"] = [];
            for (let item of this.genericArguments)
                data["genericArguments"].push(item);
        }
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITypeApiDescriptionModel {
    baseType: string | undefined;
    isEnum: boolean;
    enumNames: string[] | undefined;
    enumValues: any[] | undefined;
    genericArguments: string[] | undefined;
    properties: PropertyApiDescriptionModel[] | undefined;
}

export class ApplicationApiDescriptionModel implements IApplicationApiDescriptionModel {
    modules!: { [key: string]: ModuleApiDescriptionModel; } | undefined;
    types!: { [key: string]: TypeApiDescriptionModel; } | undefined;

    constructor(data?: IApplicationApiDescriptionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["modules"]) {
                this.modules = {} as any;
                for (let key in _data["modules"]) {
                    if (_data["modules"].hasOwnProperty(key))
                        (<any>this.modules)![key] = _data["modules"][key] ? ModuleApiDescriptionModel.fromJS(_data["modules"][key]) : new ModuleApiDescriptionModel();
                }
            }
            if (_data["types"]) {
                this.types = {} as any;
                for (let key in _data["types"]) {
                    if (_data["types"].hasOwnProperty(key))
                        (<any>this.types)![key] = _data["types"][key] ? TypeApiDescriptionModel.fromJS(_data["types"][key]) : new TypeApiDescriptionModel();
                }
            }
        }
    }

    static fromJS(data: any): ApplicationApiDescriptionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationApiDescriptionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.modules) {
            data["modules"] = {};
            for (let key in this.modules) {
                if (this.modules.hasOwnProperty(key))
                    (<any>data["modules"])[key] = this.modules[key] ? this.modules[key].toJSON() : <any>undefined;
            }
        }
        if (this.types) {
            data["types"] = {};
            for (let key in this.types) {
                if (this.types.hasOwnProperty(key))
                    (<any>data["types"])[key] = this.types[key] ? this.types[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IApplicationApiDescriptionModel {
    modules: { [key: string]: ModuleApiDescriptionModel; } | undefined;
    types: { [key: string]: TypeApiDescriptionModel; } | undefined;
}

export class RemoteServiceValidationErrorInfo implements IRemoteServiceValidationErrorInfo {
    message!: string | undefined;
    members!: string[] | undefined;

    constructor(data?: IRemoteServiceValidationErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(item);
            }
        }
    }

    static fromJS(data: any): RemoteServiceValidationErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceValidationErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item);
        }
        return data;
    }
}

export interface IRemoteServiceValidationErrorInfo {
    message: string | undefined;
    members: string[] | undefined;
}

export class RemoteServiceErrorInfo implements IRemoteServiceErrorInfo {
    code!: string | undefined;
    message!: string | undefined;
    details!: string | undefined;
    data!: { [key: string]: any; } | undefined;
    validationErrors!: RemoteServiceValidationErrorInfo[] | undefined;

    constructor(data?: IRemoteServiceErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            this.details = _data["details"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(RemoteServiceValidationErrorInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RemoteServiceErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["details"] = this.details;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRemoteServiceErrorInfo {
    code: string | undefined;
    message: string | undefined;
    details: string | undefined;
    data: { [key: string]: any; } | undefined;
    validationErrors: RemoteServiceValidationErrorInfo[] | undefined;
}

export class RemoteServiceErrorResponse implements IRemoteServiceErrorResponse {
    error!: RemoteServiceErrorInfo;

    constructor(data?: IRemoteServiceErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"] ? RemoteServiceErrorInfo.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RemoteServiceErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteServiceErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRemoteServiceErrorResponse {
    error: RemoteServiceErrorInfo;
}

export class LanguageInfo implements ILanguageInfo {
    readonly cultureName!: string | undefined;
    readonly uiCultureName!: string | undefined;
    readonly displayName!: string | undefined;
    flagIcon!: string | undefined;

    constructor(data?: ILanguageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).cultureName = _data["cultureName"];
            (<any>this).uiCultureName = _data["uiCultureName"];
            (<any>this).displayName = _data["displayName"];
            this.flagIcon = _data["flagIcon"];
        }
    }

    static fromJS(data: any): LanguageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cultureName"] = this.cultureName;
        data["uiCultureName"] = this.uiCultureName;
        data["displayName"] = this.displayName;
        data["flagIcon"] = this.flagIcon;
        return data;
    }
}

export interface ILanguageInfo {
    cultureName: string | undefined;
    uiCultureName: string | undefined;
    displayName: string | undefined;
    flagIcon: string | undefined;
}

export class DateTimeFormatDto implements IDateTimeFormatDto {
    calendarAlgorithmType!: string | undefined;
    dateTimeFormatLong!: string | undefined;
    shortDatePattern!: string | undefined;
    fullDateTimePattern!: string | undefined;
    dateSeparator!: string | undefined;
    shortTimePattern!: string | undefined;
    longTimePattern!: string | undefined;

    constructor(data?: IDateTimeFormatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.calendarAlgorithmType = _data["calendarAlgorithmType"];
            this.dateTimeFormatLong = _data["dateTimeFormatLong"];
            this.shortDatePattern = _data["shortDatePattern"];
            this.fullDateTimePattern = _data["fullDateTimePattern"];
            this.dateSeparator = _data["dateSeparator"];
            this.shortTimePattern = _data["shortTimePattern"];
            this.longTimePattern = _data["longTimePattern"];
        }
    }

    static fromJS(data: any): DateTimeFormatDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimeFormatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calendarAlgorithmType"] = this.calendarAlgorithmType;
        data["dateTimeFormatLong"] = this.dateTimeFormatLong;
        data["shortDatePattern"] = this.shortDatePattern;
        data["fullDateTimePattern"] = this.fullDateTimePattern;
        data["dateSeparator"] = this.dateSeparator;
        data["shortTimePattern"] = this.shortTimePattern;
        data["longTimePattern"] = this.longTimePattern;
        return data;
    }
}

export interface IDateTimeFormatDto {
    calendarAlgorithmType: string | undefined;
    dateTimeFormatLong: string | undefined;
    shortDatePattern: string | undefined;
    fullDateTimePattern: string | undefined;
    dateSeparator: string | undefined;
    shortTimePattern: string | undefined;
    longTimePattern: string | undefined;
}

export class CurrentCultureDto implements ICurrentCultureDto {
    displayName!: string | undefined;
    englishName!: string | undefined;
    threeLetterIsoLanguageName!: string | undefined;
    twoLetterIsoLanguageName!: string | undefined;
    isRightToLeft!: boolean;
    cultureName!: string | undefined;
    name!: string | undefined;
    nativeName!: string | undefined;
    dateTimeFormat!: DateTimeFormatDto;

    constructor(data?: ICurrentCultureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.englishName = _data["englishName"];
            this.threeLetterIsoLanguageName = _data["threeLetterIsoLanguageName"];
            this.twoLetterIsoLanguageName = _data["twoLetterIsoLanguageName"];
            this.isRightToLeft = _data["isRightToLeft"];
            this.cultureName = _data["cultureName"];
            this.name = _data["name"];
            this.nativeName = _data["nativeName"];
            this.dateTimeFormat = _data["dateTimeFormat"] ? DateTimeFormatDto.fromJS(_data["dateTimeFormat"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CurrentCultureDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentCultureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["englishName"] = this.englishName;
        data["threeLetterIsoLanguageName"] = this.threeLetterIsoLanguageName;
        data["twoLetterIsoLanguageName"] = this.twoLetterIsoLanguageName;
        data["isRightToLeft"] = this.isRightToLeft;
        data["cultureName"] = this.cultureName;
        data["name"] = this.name;
        data["nativeName"] = this.nativeName;
        data["dateTimeFormat"] = this.dateTimeFormat ? this.dateTimeFormat.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICurrentCultureDto {
    displayName: string | undefined;
    englishName: string | undefined;
    threeLetterIsoLanguageName: string | undefined;
    twoLetterIsoLanguageName: string | undefined;
    isRightToLeft: boolean;
    cultureName: string | undefined;
    name: string | undefined;
    nativeName: string | undefined;
    dateTimeFormat: DateTimeFormatDto;
}

export class NameValue implements INameValue {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class ApplicationLocalizationConfigurationDto implements IApplicationLocalizationConfigurationDto {
    values!: { [key: string]: { [key: string]: string; }; } | undefined;
    languages!: LanguageInfo[] | undefined;
    currentCulture!: CurrentCultureDto;
    defaultResourceName!: string | undefined;
    languagesMap!: { [key: string]: NameValue[]; } | undefined;
    languageFilesMap!: { [key: string]: NameValue[]; } | undefined;

    constructor(data?: IApplicationLocalizationConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key] !== undefined ? _data["values"][key] : {};
                }
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(LanguageInfo.fromJS(item));
            }
            this.currentCulture = _data["currentCulture"] ? CurrentCultureDto.fromJS(_data["currentCulture"]) : <any>undefined;
            this.defaultResourceName = _data["defaultResourceName"];
            if (_data["languagesMap"]) {
                this.languagesMap = {} as any;
                for (let key in _data["languagesMap"]) {
                    if (_data["languagesMap"].hasOwnProperty(key))
                        (<any>this.languagesMap)![key] = _data["languagesMap"][key] ? _data["languagesMap"][key].map((i: any) => NameValue.fromJS(i)) : [];
                }
            }
            if (_data["languageFilesMap"]) {
                this.languageFilesMap = {} as any;
                for (let key in _data["languageFilesMap"]) {
                    if (_data["languageFilesMap"].hasOwnProperty(key))
                        (<any>this.languageFilesMap)![key] = _data["languageFilesMap"][key] ? _data["languageFilesMap"][key].map((i: any) => NameValue.fromJS(i)) : [];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationLocalizationConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLocalizationConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = (<any>this.values)[key];
            }
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["currentCulture"] = this.currentCulture ? this.currentCulture.toJSON() : <any>undefined;
        data["defaultResourceName"] = this.defaultResourceName;
        if (this.languagesMap) {
            data["languagesMap"] = {};
            for (let key in this.languagesMap) {
                if (this.languagesMap.hasOwnProperty(key))
                    (<any>data["languagesMap"])[key] = (<any>this.languagesMap)[key];
            }
        }
        if (this.languageFilesMap) {
            data["languageFilesMap"] = {};
            for (let key in this.languageFilesMap) {
                if (this.languageFilesMap.hasOwnProperty(key))
                    (<any>data["languageFilesMap"])[key] = (<any>this.languageFilesMap)[key];
            }
        }
        return data;
    }
}

export interface IApplicationLocalizationConfigurationDto {
    values: { [key: string]: { [key: string]: string; }; } | undefined;
    languages: LanguageInfo[] | undefined;
    currentCulture: CurrentCultureDto;
    defaultResourceName: string | undefined;
    languagesMap: { [key: string]: NameValue[]; } | undefined;
    languageFilesMap: { [key: string]: NameValue[]; } | undefined;
}

export class ApplicationAuthConfigurationDto implements IApplicationAuthConfigurationDto {
    policies!: { [key: string]: boolean; } | undefined;
    grantedPolicies!: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationAuthConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["policies"]) {
                this.policies = {} as any;
                for (let key in _data["policies"]) {
                    if (_data["policies"].hasOwnProperty(key))
                        (<any>this.policies)![key] = _data["policies"][key];
                }
            }
            if (_data["grantedPolicies"]) {
                this.grantedPolicies = {} as any;
                for (let key in _data["grantedPolicies"]) {
                    if (_data["grantedPolicies"].hasOwnProperty(key))
                        (<any>this.grantedPolicies)![key] = _data["grantedPolicies"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationAuthConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationAuthConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.policies) {
            data["policies"] = {};
            for (let key in this.policies) {
                if (this.policies.hasOwnProperty(key))
                    (<any>data["policies"])[key] = (<any>this.policies)[key];
            }
        }
        if (this.grantedPolicies) {
            data["grantedPolicies"] = {};
            for (let key in this.grantedPolicies) {
                if (this.grantedPolicies.hasOwnProperty(key))
                    (<any>data["grantedPolicies"])[key] = (<any>this.grantedPolicies)[key];
            }
        }
        return data;
    }
}

export interface IApplicationAuthConfigurationDto {
    policies: { [key: string]: boolean; } | undefined;
    grantedPolicies: { [key: string]: boolean; } | undefined;
}

export class ApplicationSettingConfigurationDto implements IApplicationSettingConfigurationDto {
    values!: { [key: string]: string; } | undefined;

    constructor(data?: IApplicationSettingConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationSettingConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationSettingConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = (<any>this.values)[key];
            }
        }
        return data;
    }
}

export interface IApplicationSettingConfigurationDto {
    values: { [key: string]: string; } | undefined;
}

export class CurrentUserDto implements ICurrentUserDto {
    isAuthenticated!: boolean;
    id!: string | undefined;
    tenantId!: string | undefined;
    userName!: string | undefined;
    name!: string | undefined;
    surName!: string | undefined;
    email!: string | undefined;
    emailVerified!: boolean;
    phoneNumber!: string | undefined;
    phoneNumberVerified!: boolean;
    roles!: string[] | undefined;

    constructor(data?: ICurrentUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAuthenticated = _data["isAuthenticated"];
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surName = _data["surName"];
            this.email = _data["email"];
            this.emailVerified = _data["emailVerified"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberVerified = _data["phoneNumberVerified"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CurrentUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAuthenticated"] = this.isAuthenticated;
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surName"] = this.surName;
        data["email"] = this.email;
        data["emailVerified"] = this.emailVerified;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberVerified"] = this.phoneNumberVerified;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ICurrentUserDto {
    isAuthenticated: boolean;
    id: string | undefined;
    tenantId: string | undefined;
    userName: string | undefined;
    name: string | undefined;
    surName: string | undefined;
    email: string | undefined;
    emailVerified: boolean;
    phoneNumber: string | undefined;
    phoneNumberVerified: boolean;
    roles: string[] | undefined;
}

export class ApplicationFeatureConfigurationDto implements IApplicationFeatureConfigurationDto {
    values!: { [key: string]: string; } | undefined;

    constructor(data?: IApplicationFeatureConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["values"]) {
                this.values = {} as any;
                for (let key in _data["values"]) {
                    if (_data["values"].hasOwnProperty(key))
                        (<any>this.values)![key] = _data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationFeatureConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationFeatureConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["values"])[key] = (<any>this.values)[key];
            }
        }
        return data;
    }
}

export interface IApplicationFeatureConfigurationDto {
    values: { [key: string]: string; } | undefined;
}

export class MultiTenancyInfoDto implements IMultiTenancyInfoDto {
    isEnabled!: boolean;

    constructor(data?: IMultiTenancyInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): MultiTenancyInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MultiTenancyInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IMultiTenancyInfoDto {
    isEnabled: boolean;
}

export class CurrentTenantDto implements ICurrentTenantDto {
    id!: string | undefined;
    name!: string | undefined;
    isAvailable!: boolean;

    constructor(data?: ICurrentTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): CurrentTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface ICurrentTenantDto {
    id: string | undefined;
    name: string | undefined;
    isAvailable: boolean;
}

export class IanaTimeZone implements IIanaTimeZone {
    timeZoneName!: string | undefined;

    constructor(data?: IIanaTimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZoneName = _data["timeZoneName"];
        }
    }

    static fromJS(data: any): IanaTimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new IanaTimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneName"] = this.timeZoneName;
        return data;
    }
}

export interface IIanaTimeZone {
    timeZoneName: string | undefined;
}

export class WindowsTimeZone implements IWindowsTimeZone {
    timeZoneId!: string | undefined;

    constructor(data?: IWindowsTimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZoneId = _data["timeZoneId"];
        }
    }

    static fromJS(data: any): WindowsTimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new WindowsTimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneId"] = this.timeZoneId;
        return data;
    }
}

export interface IWindowsTimeZone {
    timeZoneId: string | undefined;
}

export class TimeZone implements ITimeZone {
    iana!: IanaTimeZone;
    windows!: WindowsTimeZone;

    constructor(data?: ITimeZone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iana = _data["iana"] ? IanaTimeZone.fromJS(_data["iana"]) : <any>undefined;
            this.windows = _data["windows"] ? WindowsTimeZone.fromJS(_data["windows"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimeZone {
        data = typeof data === 'object' ? data : {};
        let result = new TimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iana"] = this.iana ? this.iana.toJSON() : <any>undefined;
        data["windows"] = this.windows ? this.windows.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITimeZone {
    iana: IanaTimeZone;
    windows: WindowsTimeZone;
}

export class TimingDto implements ITimingDto {
    timeZone!: TimeZone;

    constructor(data?: ITimingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeZone = _data["timeZone"] ? TimeZone.fromJS(_data["timeZone"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimingDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZone"] = this.timeZone ? this.timeZone.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITimingDto {
    timeZone: TimeZone;
}

export class ClockDto implements IClockDto {
    kind!: string | undefined;

    constructor(data?: IClockDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kind = _data["kind"];
        }
    }

    static fromJS(data: any): ClockDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClockDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind;
        return data;
    }
}

export interface IClockDto {
    kind: string | undefined;
}

export class LocalizableStringDto implements ILocalizableStringDto {
    readonly name!: string | undefined;
    resource!: string | undefined;

    constructor(data?: ILocalizableStringDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            this.resource = _data["resource"];
        }
    }

    static fromJS(data: any): LocalizableStringDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableStringDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["resource"] = this.resource;
        return data;
    }
}

export interface ILocalizableStringDto {
    name: string | undefined;
    resource: string | undefined;
}

export class ExtensionPropertyApiGetDto implements IExtensionPropertyApiGetDto {
    isAvailable!: boolean;

    constructor(data?: IExtensionPropertyApiGetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ExtensionPropertyApiGetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiGetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IExtensionPropertyApiGetDto {
    isAvailable: boolean;
}

export class ExtensionPropertyApiCreateDto implements IExtensionPropertyApiCreateDto {
    isAvailable!: boolean;

    constructor(data?: IExtensionPropertyApiCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ExtensionPropertyApiCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IExtensionPropertyApiCreateDto {
    isAvailable: boolean;
}

export class ExtensionPropertyApiUpdateDto implements IExtensionPropertyApiUpdateDto {
    isAvailable!: boolean;

    constructor(data?: IExtensionPropertyApiUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"];
        }
    }

    static fromJS(data: any): ExtensionPropertyApiUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable;
        return data;
    }
}

export interface IExtensionPropertyApiUpdateDto {
    isAvailable: boolean;
}

export class ExtensionPropertyApiDto implements IExtensionPropertyApiDto {
    onGet!: ExtensionPropertyApiGetDto;
    onCreate!: ExtensionPropertyApiCreateDto;
    onUpdate!: ExtensionPropertyApiUpdateDto;

    constructor(data?: IExtensionPropertyApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onGet = _data["onGet"] ? ExtensionPropertyApiGetDto.fromJS(_data["onGet"]) : <any>undefined;
            this.onCreate = _data["onCreate"] ? ExtensionPropertyApiCreateDto.fromJS(_data["onCreate"]) : <any>undefined;
            this.onUpdate = _data["onUpdate"] ? ExtensionPropertyApiUpdateDto.fromJS(_data["onUpdate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtensionPropertyApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onGet"] = this.onGet ? this.onGet.toJSON() : <any>undefined;
        data["onCreate"] = this.onCreate ? this.onCreate.toJSON() : <any>undefined;
        data["onUpdate"] = this.onUpdate ? this.onUpdate.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExtensionPropertyApiDto {
    onGet: ExtensionPropertyApiGetDto;
    onCreate: ExtensionPropertyApiCreateDto;
    onUpdate: ExtensionPropertyApiUpdateDto;
}

export class ExtensionPropertyUiTableDto implements IExtensionPropertyUiTableDto {
    isVisible!: boolean;

    constructor(data?: IExtensionPropertyUiTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any): ExtensionPropertyUiTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isVisible"] = this.isVisible;
        return data;
    }
}

export interface IExtensionPropertyUiTableDto {
    isVisible: boolean;
}

export class ExtensionPropertyUiFormDto implements IExtensionPropertyUiFormDto {
    isVisible!: boolean;

    constructor(data?: IExtensionPropertyUiFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isVisible = _data["isVisible"];
        }
    }

    static fromJS(data: any): ExtensionPropertyUiFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isVisible"] = this.isVisible;
        return data;
    }
}

export interface IExtensionPropertyUiFormDto {
    isVisible: boolean;
}

export class ExtensionPropertyUiLookupDto implements IExtensionPropertyUiLookupDto {
    url!: string | undefined;
    resultListPropertyName!: string | undefined;
    displayPropertyName!: string | undefined;
    valuePropertyName!: string | undefined;
    filterParamName!: string | undefined;

    constructor(data?: IExtensionPropertyUiLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.resultListPropertyName = _data["resultListPropertyName"];
            this.displayPropertyName = _data["displayPropertyName"];
            this.valuePropertyName = _data["valuePropertyName"];
            this.filterParamName = _data["filterParamName"];
        }
    }

    static fromJS(data: any): ExtensionPropertyUiLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["resultListPropertyName"] = this.resultListPropertyName;
        data["displayPropertyName"] = this.displayPropertyName;
        data["valuePropertyName"] = this.valuePropertyName;
        data["filterParamName"] = this.filterParamName;
        return data;
    }
}

export interface IExtensionPropertyUiLookupDto {
    url: string | undefined;
    resultListPropertyName: string | undefined;
    displayPropertyName: string | undefined;
    valuePropertyName: string | undefined;
    filterParamName: string | undefined;
}

export class ExtensionPropertyUiDto implements IExtensionPropertyUiDto {
    onTable!: ExtensionPropertyUiTableDto;
    onCreateForm!: ExtensionPropertyUiFormDto;
    onEditForm!: ExtensionPropertyUiFormDto;
    lookup!: ExtensionPropertyUiLookupDto;

    constructor(data?: IExtensionPropertyUiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onTable = _data["onTable"] ? ExtensionPropertyUiTableDto.fromJS(_data["onTable"]) : <any>undefined;
            this.onCreateForm = _data["onCreateForm"] ? ExtensionPropertyUiFormDto.fromJS(_data["onCreateForm"]) : <any>undefined;
            this.onEditForm = _data["onEditForm"] ? ExtensionPropertyUiFormDto.fromJS(_data["onEditForm"]) : <any>undefined;
            this.lookup = _data["lookup"] ? ExtensionPropertyUiLookupDto.fromJS(_data["lookup"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtensionPropertyUiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyUiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onTable"] = this.onTable ? this.onTable.toJSON() : <any>undefined;
        data["onCreateForm"] = this.onCreateForm ? this.onCreateForm.toJSON() : <any>undefined;
        data["onEditForm"] = this.onEditForm ? this.onEditForm.toJSON() : <any>undefined;
        data["lookup"] = this.lookup ? this.lookup.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExtensionPropertyUiDto {
    onTable: ExtensionPropertyUiTableDto;
    onCreateForm: ExtensionPropertyUiFormDto;
    onEditForm: ExtensionPropertyUiFormDto;
    lookup: ExtensionPropertyUiLookupDto;
}

export class ExtensionPropertyAttributeDto implements IExtensionPropertyAttributeDto {
    typeSimple!: string | undefined;
    config!: { [key: string]: any; } | undefined;

    constructor(data?: IExtensionPropertyAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeSimple = _data["typeSimple"];
            if (_data["config"]) {
                this.config = {} as any;
                for (let key in _data["config"]) {
                    if (_data["config"].hasOwnProperty(key))
                        (<any>this.config)![key] = _data["config"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExtensionPropertyAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeSimple"] = this.typeSimple;
        if (this.config) {
            data["config"] = {};
            for (let key in this.config) {
                if (this.config.hasOwnProperty(key))
                    (<any>data["config"])[key] = (<any>this.config)[key];
            }
        }
        return data;
    }
}

export interface IExtensionPropertyAttributeDto {
    typeSimple: string | undefined;
    config: { [key: string]: any; } | undefined;
}

export class ExtensionPropertyDto implements IExtensionPropertyDto {
    type!: string | undefined;
    typeSimple!: string | undefined;
    displayName!: LocalizableStringDto;
    api!: ExtensionPropertyApiDto;
    ui!: ExtensionPropertyUiDto;
    attributes!: ExtensionPropertyAttributeDto[] | undefined;
    configuration!: { [key: string]: any; } | undefined;
    defaultValue!: any | undefined;

    constructor(data?: IExtensionPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.typeSimple = _data["typeSimple"];
            this.displayName = _data["displayName"] ? LocalizableStringDto.fromJS(_data["displayName"]) : <any>undefined;
            this.api = _data["api"] ? ExtensionPropertyApiDto.fromJS(_data["api"]) : <any>undefined;
            this.ui = _data["ui"] ? ExtensionPropertyUiDto.fromJS(_data["ui"]) : <any>undefined;
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ExtensionPropertyAttributeDto.fromJS(item));
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
            this.defaultValue = _data["defaultValue"];
        }
    }

    static fromJS(data: any): ExtensionPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["typeSimple"] = this.typeSimple;
        data["displayName"] = this.displayName ? this.displayName.toJSON() : <any>undefined;
        data["api"] = this.api ? this.api.toJSON() : <any>undefined;
        data["ui"] = this.ui ? this.ui.toJSON() : <any>undefined;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        data["defaultValue"] = this.defaultValue;
        return data;
    }
}

export interface IExtensionPropertyDto {
    type: string | undefined;
    typeSimple: string | undefined;
    displayName: LocalizableStringDto;
    api: ExtensionPropertyApiDto;
    ui: ExtensionPropertyUiDto;
    attributes: ExtensionPropertyAttributeDto[] | undefined;
    configuration: { [key: string]: any; } | undefined;
    defaultValue: any | undefined;
}

export class EntityExtensionDto implements IEntityExtensionDto {
    properties!: { [key: string]: ExtensionPropertyDto; } | undefined;
    configuration!: { [key: string]: any; } | undefined;

    constructor(data?: IEntityExtensionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? ExtensionPropertyDto.fromJS(_data["properties"][key]) : new ExtensionPropertyDto();
                }
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
        }
    }

    static fromJS(data: any): EntityExtensionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityExtensionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        return data;
    }
}

export interface IEntityExtensionDto {
    properties: { [key: string]: ExtensionPropertyDto; } | undefined;
    configuration: { [key: string]: any; } | undefined;
}

export class ModuleExtensionDto implements IModuleExtensionDto {
    entities!: { [key: string]: EntityExtensionDto; } | undefined;
    configuration!: { [key: string]: any; } | undefined;

    constructor(data?: IModuleExtensionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["entities"]) {
                this.entities = {} as any;
                for (let key in _data["entities"]) {
                    if (_data["entities"].hasOwnProperty(key))
                        (<any>this.entities)![key] = _data["entities"][key] ? EntityExtensionDto.fromJS(_data["entities"][key]) : new EntityExtensionDto();
                }
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
        }
    }

    static fromJS(data: any): ModuleExtensionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleExtensionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.entities) {
            data["entities"] = {};
            for (let key in this.entities) {
                if (this.entities.hasOwnProperty(key))
                    (<any>data["entities"])[key] = this.entities[key] ? this.entities[key].toJSON() : <any>undefined;
            }
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        return data;
    }
}

export interface IModuleExtensionDto {
    entities: { [key: string]: EntityExtensionDto; } | undefined;
    configuration: { [key: string]: any; } | undefined;
}

export class ExtensionEnumFieldDto implements IExtensionEnumFieldDto {
    name!: string | undefined;
    value!: any | undefined;

    constructor(data?: IExtensionEnumFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ExtensionEnumFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionEnumFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IExtensionEnumFieldDto {
    name: string | undefined;
    value: any | undefined;
}

export class ExtensionEnumDto implements IExtensionEnumDto {
    fields!: ExtensionEnumFieldDto[] | undefined;
    localizationResource!: string | undefined;

    constructor(data?: IExtensionEnumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(ExtensionEnumFieldDto.fromJS(item));
            }
            this.localizationResource = _data["localizationResource"];
        }
    }

    static fromJS(data: any): ExtensionEnumDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionEnumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["localizationResource"] = this.localizationResource;
        return data;
    }
}

export interface IExtensionEnumDto {
    fields: ExtensionEnumFieldDto[] | undefined;
    localizationResource: string | undefined;
}

export class ObjectExtensionsDto implements IObjectExtensionsDto {
    modules!: { [key: string]: ModuleExtensionDto; } | undefined;
    enums!: { [key: string]: ExtensionEnumDto; } | undefined;

    constructor(data?: IObjectExtensionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["modules"]) {
                this.modules = {} as any;
                for (let key in _data["modules"]) {
                    if (_data["modules"].hasOwnProperty(key))
                        (<any>this.modules)![key] = _data["modules"][key] ? ModuleExtensionDto.fromJS(_data["modules"][key]) : new ModuleExtensionDto();
                }
            }
            if (_data["enums"]) {
                this.enums = {} as any;
                for (let key in _data["enums"]) {
                    if (_data["enums"].hasOwnProperty(key))
                        (<any>this.enums)![key] = _data["enums"][key] ? ExtensionEnumDto.fromJS(_data["enums"][key]) : new ExtensionEnumDto();
                }
            }
        }
    }

    static fromJS(data: any): ObjectExtensionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectExtensionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.modules) {
            data["modules"] = {};
            for (let key in this.modules) {
                if (this.modules.hasOwnProperty(key))
                    (<any>data["modules"])[key] = this.modules[key] ? this.modules[key].toJSON() : <any>undefined;
            }
        }
        if (this.enums) {
            data["enums"] = {};
            for (let key in this.enums) {
                if (this.enums.hasOwnProperty(key))
                    (<any>data["enums"])[key] = this.enums[key] ? this.enums[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IObjectExtensionsDto {
    modules: { [key: string]: ModuleExtensionDto; } | undefined;
    enums: { [key: string]: ExtensionEnumDto; } | undefined;
}

export class ApplicationConfigurationDto implements IApplicationConfigurationDto {
    localization!: ApplicationLocalizationConfigurationDto;
    auth!: ApplicationAuthConfigurationDto;
    setting!: ApplicationSettingConfigurationDto;
    currentUser!: CurrentUserDto;
    features!: ApplicationFeatureConfigurationDto;
    multiTenancy!: MultiTenancyInfoDto;
    currentTenant!: CurrentTenantDto;
    timing!: TimingDto;
    clock!: ClockDto;
    objectExtensions!: ObjectExtensionsDto;

    constructor(data?: IApplicationConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localization = _data["localization"] ? ApplicationLocalizationConfigurationDto.fromJS(_data["localization"]) : <any>undefined;
            this.auth = _data["auth"] ? ApplicationAuthConfigurationDto.fromJS(_data["auth"]) : <any>undefined;
            this.setting = _data["setting"] ? ApplicationSettingConfigurationDto.fromJS(_data["setting"]) : <any>undefined;
            this.currentUser = _data["currentUser"] ? CurrentUserDto.fromJS(_data["currentUser"]) : <any>undefined;
            this.features = _data["features"] ? ApplicationFeatureConfigurationDto.fromJS(_data["features"]) : <any>undefined;
            this.multiTenancy = _data["multiTenancy"] ? MultiTenancyInfoDto.fromJS(_data["multiTenancy"]) : <any>undefined;
            this.currentTenant = _data["currentTenant"] ? CurrentTenantDto.fromJS(_data["currentTenant"]) : <any>undefined;
            this.timing = _data["timing"] ? TimingDto.fromJS(_data["timing"]) : <any>undefined;
            this.clock = _data["clock"] ? ClockDto.fromJS(_data["clock"]) : <any>undefined;
            this.objectExtensions = _data["objectExtensions"] ? ObjectExtensionsDto.fromJS(_data["objectExtensions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localization"] = this.localization ? this.localization.toJSON() : <any>undefined;
        data["auth"] = this.auth ? this.auth.toJSON() : <any>undefined;
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        data["currentUser"] = this.currentUser ? this.currentUser.toJSON() : <any>undefined;
        data["features"] = this.features ? this.features.toJSON() : <any>undefined;
        data["multiTenancy"] = this.multiTenancy ? this.multiTenancy.toJSON() : <any>undefined;
        data["currentTenant"] = this.currentTenant ? this.currentTenant.toJSON() : <any>undefined;
        data["timing"] = this.timing ? this.timing.toJSON() : <any>undefined;
        data["clock"] = this.clock ? this.clock.toJSON() : <any>undefined;
        data["objectExtensions"] = this.objectExtensions ? this.objectExtensions.toJSON() : <any>undefined;
        return data;
    }
}

export interface IApplicationConfigurationDto {
    localization: ApplicationLocalizationConfigurationDto;
    auth: ApplicationAuthConfigurationDto;
    setting: ApplicationSettingConfigurationDto;
    currentUser: CurrentUserDto;
    features: ApplicationFeatureConfigurationDto;
    multiTenancy: MultiTenancyInfoDto;
    currentTenant: CurrentTenantDto;
    timing: TimingDto;
    clock: ClockDto;
    objectExtensions: ObjectExtensionsDto;
}

export class AuthJwtDto implements IAuthJwtDto {
    access_token!: string | undefined;
    expires_in!: number;
    token_type!: string | undefined;
    refresh_token!: string | undefined;

    constructor(data?: IAuthJwtDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.access_token = _data["access_token"];
            this.expires_in = _data["expires_in"];
            this.token_type = _data["token_type"];
            this.refresh_token = _data["refresh_token"];
        }
    }

    static fromJS(data: any): AuthJwtDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthJwtDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_token"] = this.access_token;
        data["expires_in"] = this.expires_in;
        data["token_type"] = this.token_type;
        data["refresh_token"] = this.refresh_token;
        return data;
    }
}

export interface IAuthJwtDto {
    access_token: string | undefined;
    expires_in: number;
    token_type: string | undefined;
    refresh_token: string | undefined;
}

export class LoginResultDto implements ILoginResultDto {
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    authJwtDto!: AuthJwtDto;

    constructor(data?: ILoginResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.authJwtDto = _data["authJwtDto"] ? AuthJwtDto.fromJS(_data["authJwtDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LoginResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["authJwtDto"] = this.authJwtDto ? this.authJwtDto.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILoginResultDto {
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    authJwtDto: AuthJwtDto;
}

export class AccountPasswordlessLoginQuery implements IAccountPasswordlessLoginQuery {
    userId!: string;

    constructor(data?: IAccountPasswordlessLoginQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AccountPasswordlessLoginQuery {
        data = typeof data === 'object' ? data : {};
        let result = new AccountPasswordlessLoginQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }
}

export interface IAccountPasswordlessLoginQuery {
    userId: string;
}

export class PagingListBookingRequest implements IPagingListBookingRequest {
    ngayLap!: DateTime | undefined;
    sysUerId!: number | undefined;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingListBookingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ngayLap = _data["ngayLap"] ? DateTime.fromISO(_data["ngayLap"].toString()) : <any>undefined;
            this.sysUerId = _data["sysUerId"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingListBookingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingListBookingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ngayLap"] = this.ngayLap ? this.ngayLap.toString() : <any>undefined;
        data["sysUerId"] = this.sysUerId;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingListBookingRequest {
    ngayLap: DateTime | undefined;
    sysUerId: number | undefined;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class ThongTinChungBookingDto implements IThongTinChungBookingDto {
    ma!: string | undefined;
    ten!: string | undefined;
    tinhId!: number | undefined;
    tenTinh!: string | undefined;
    kenhBanHang!: string | undefined;
    nhanVienId!: number;
    tenNhanVien!: string | undefined;
    ghiChu!: string | undefined;
    tenTour!: string | undefined;
    soLuongNguoi!: number;
    phuongThucCode!: string | undefined;
    loaiKhachHangCode!: string | undefined;
    khachHangId!: number;
    sysUerId!: number | undefined;
    tenKhachHang!: string | undefined;
    quocTich!: string | undefined;
    email!: string | undefined;
    soDienThoai!: string | undefined;
    diaChi!: string | undefined;
    trangThai!: number | undefined;
    ngayLap!: DateTime | undefined;
    thanhTien!: number | undefined;
    id!: number;

    constructor(data?: IThongTinChungBookingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.tinhId = _data["tinhId"];
            this.tenTinh = _data["tenTinh"];
            this.kenhBanHang = _data["kenhBanHang"];
            this.nhanVienId = _data["nhanVienId"];
            this.tenNhanVien = _data["tenNhanVien"];
            this.ghiChu = _data["ghiChu"];
            this.tenTour = _data["tenTour"];
            this.soLuongNguoi = _data["soLuongNguoi"];
            this.phuongThucCode = _data["phuongThucCode"];
            this.loaiKhachHangCode = _data["loaiKhachHangCode"];
            this.khachHangId = _data["khachHangId"];
            this.sysUerId = _data["sysUerId"];
            this.tenKhachHang = _data["tenKhachHang"];
            this.quocTich = _data["quocTich"];
            this.email = _data["email"];
            this.soDienThoai = _data["soDienThoai"];
            this.diaChi = _data["diaChi"];
            this.trangThai = _data["trangThai"];
            this.ngayLap = _data["ngayLap"] ? DateTime.fromISO(_data["ngayLap"].toString()) : <any>undefined;
            this.thanhTien = _data["thanhTien"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ThongTinChungBookingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongTinChungBookingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["tinhId"] = this.tinhId;
        data["tenTinh"] = this.tenTinh;
        data["kenhBanHang"] = this.kenhBanHang;
        data["nhanVienId"] = this.nhanVienId;
        data["tenNhanVien"] = this.tenNhanVien;
        data["ghiChu"] = this.ghiChu;
        data["tenTour"] = this.tenTour;
        data["soLuongNguoi"] = this.soLuongNguoi;
        data["phuongThucCode"] = this.phuongThucCode;
        data["loaiKhachHangCode"] = this.loaiKhachHangCode;
        data["khachHangId"] = this.khachHangId;
        data["sysUerId"] = this.sysUerId;
        data["tenKhachHang"] = this.tenKhachHang;
        data["quocTich"] = this.quocTich;
        data["email"] = this.email;
        data["soDienThoai"] = this.soDienThoai;
        data["diaChi"] = this.diaChi;
        data["trangThai"] = this.trangThai;
        data["ngayLap"] = this.ngayLap ? this.ngayLap.toString() : <any>undefined;
        data["thanhTien"] = this.thanhTien;
        data["id"] = this.id;
        return data;
    }
}

export interface IThongTinChungBookingDto {
    ma: string | undefined;
    ten: string | undefined;
    tinhId: number | undefined;
    tenTinh: string | undefined;
    kenhBanHang: string | undefined;
    nhanVienId: number;
    tenNhanVien: string | undefined;
    ghiChu: string | undefined;
    tenTour: string | undefined;
    soLuongNguoi: number;
    phuongThucCode: string | undefined;
    loaiKhachHangCode: string | undefined;
    khachHangId: number;
    sysUerId: number | undefined;
    tenKhachHang: string | undefined;
    quocTich: string | undefined;
    email: string | undefined;
    soDienThoai: string | undefined;
    diaChi: string | undefined;
    trangThai: number | undefined;
    ngayLap: DateTime | undefined;
    thanhTien: number | undefined;
    id: number;
}

export class ThongTinChungBookingDtoPagedResultDto implements IThongTinChungBookingDtoPagedResultDto {
    totalCount!: number;
    items!: ThongTinChungBookingDto[] | undefined;

    constructor(data?: IThongTinChungBookingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ThongTinChungBookingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ThongTinChungBookingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThongTinChungBookingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IThongTinChungBookingDtoPagedResultDto {
    totalCount: number;
    items: ThongTinChungBookingDto[] | undefined;
}

export class CreateOrUpdatThongTinBookingDto implements ICreateOrUpdatThongTinBookingDto {
    ma!: string | undefined;
    tinhId!: string | undefined;
    kenhBanHang!: string | undefined;
    nhanVienId!: number | undefined;
    ghiChu!: string | undefined;
    ten!: string | undefined;
    loaiKhachHangCode!: string | undefined;
    khachHangId!: number | undefined;
    sysUerId!: number | undefined;
    tenKhachHang!: string | undefined;
    soDienThoai!: string | undefined;
    email!: string | undefined;
    quocTichId!: string | undefined;
    diaChi!: string | undefined;
    phuongThucCode!: string | undefined;
    id!: number;

    constructor(data?: ICreateOrUpdatThongTinBookingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma = _data["ma"];
            this.tinhId = _data["tinhId"];
            this.kenhBanHang = _data["kenhBanHang"];
            this.nhanVienId = _data["nhanVienId"];
            this.ghiChu = _data["ghiChu"];
            this.ten = _data["ten"];
            this.loaiKhachHangCode = _data["loaiKhachHangCode"];
            this.khachHangId = _data["khachHangId"];
            this.sysUerId = _data["sysUerId"];
            this.tenKhachHang = _data["tenKhachHang"];
            this.soDienThoai = _data["soDienThoai"];
            this.email = _data["email"];
            this.quocTichId = _data["quocTichId"];
            this.diaChi = _data["diaChi"];
            this.phuongThucCode = _data["phuongThucCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdatThongTinBookingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdatThongTinBookingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma"] = this.ma;
        data["tinhId"] = this.tinhId;
        data["kenhBanHang"] = this.kenhBanHang;
        data["nhanVienId"] = this.nhanVienId;
        data["ghiChu"] = this.ghiChu;
        data["ten"] = this.ten;
        data["loaiKhachHangCode"] = this.loaiKhachHangCode;
        data["khachHangId"] = this.khachHangId;
        data["sysUerId"] = this.sysUerId;
        data["tenKhachHang"] = this.tenKhachHang;
        data["soDienThoai"] = this.soDienThoai;
        data["email"] = this.email;
        data["quocTichId"] = this.quocTichId;
        data["diaChi"] = this.diaChi;
        data["phuongThucCode"] = this.phuongThucCode;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrUpdatThongTinBookingDto {
    ma: string | undefined;
    tinhId: string | undefined;
    kenhBanHang: string | undefined;
    nhanVienId: number | undefined;
    ghiChu: string | undefined;
    ten: string | undefined;
    loaiKhachHangCode: string | undefined;
    khachHangId: number | undefined;
    sysUerId: number | undefined;
    tenKhachHang: string | undefined;
    soDienThoai: string | undefined;
    email: string | undefined;
    quocTichId: string | undefined;
    diaChi: string | undefined;
    phuongThucCode: string | undefined;
    id: number;
}

export class CrudChiTietDichVuBookingTour implements ICrudChiTietDichVuBookingTour {
    bookingId!: number;
    bookingTourId!: number;
    loaiDoTuoi!: string | undefined;
    giaNett!: number;
    giaBan!: number;
    soLuong!: number;
    thanhTien!: number;
    id!: number;

    constructor(data?: ICrudChiTietDichVuBookingTour) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookingId = _data["bookingId"];
            this.bookingTourId = _data["bookingTourId"];
            this.loaiDoTuoi = _data["loaiDoTuoi"];
            this.giaNett = _data["giaNett"];
            this.giaBan = _data["giaBan"];
            this.soLuong = _data["soLuong"];
            this.thanhTien = _data["thanhTien"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CrudChiTietDichVuBookingTour {
        data = typeof data === 'object' ? data : {};
        let result = new CrudChiTietDichVuBookingTour();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookingId"] = this.bookingId;
        data["bookingTourId"] = this.bookingTourId;
        data["loaiDoTuoi"] = this.loaiDoTuoi;
        data["giaNett"] = this.giaNett;
        data["giaBan"] = this.giaBan;
        data["soLuong"] = this.soLuong;
        data["thanhTien"] = this.thanhTien;
        data["id"] = this.id;
        return data;
    }
}

export interface ICrudChiTietDichVuBookingTour {
    bookingId: number;
    bookingTourId: number;
    loaiDoTuoi: string | undefined;
    giaNett: number;
    giaBan: number;
    soLuong: number;
    thanhTien: number;
    id: number;
}

export class CreateOrUpdateDichVuBookingTourDto implements ICreateOrUpdateDichVuBookingTourDto {
    bookingId!: number;
    tourId!: number | undefined;
    tenTour!: string | undefined;
    ngayBatDau!: DateTime | undefined;
    soLuongNguoiLon!: number | undefined;
    soLuongTreEm!: number | undefined;
    diemDen!: string | undefined;
    gioDon!: DateTime | undefined;
    listChiTiet!: CrudChiTietDichVuBookingTour[] | undefined;
    id!: number;

    constructor(data?: ICreateOrUpdateDichVuBookingTourDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookingId = _data["bookingId"];
            this.tourId = _data["tourId"];
            this.tenTour = _data["tenTour"];
            this.ngayBatDau = _data["ngayBatDau"] ? DateTime.fromISO(_data["ngayBatDau"].toString()) : <any>undefined;
            this.soLuongNguoiLon = _data["soLuongNguoiLon"];
            this.soLuongTreEm = _data["soLuongTreEm"];
            this.diemDen = _data["diemDen"];
            this.gioDon = _data["gioDon"] ? DateTime.fromISO(_data["gioDon"].toString()) : <any>undefined;
            if (Array.isArray(_data["listChiTiet"])) {
                this.listChiTiet = [] as any;
                for (let item of _data["listChiTiet"])
                    this.listChiTiet!.push(CrudChiTietDichVuBookingTour.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateDichVuBookingTourDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateDichVuBookingTourDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookingId"] = this.bookingId;
        data["tourId"] = this.tourId;
        data["tenTour"] = this.tenTour;
        data["ngayBatDau"] = this.ngayBatDau ? this.ngayBatDau.toString() : <any>undefined;
        data["soLuongNguoiLon"] = this.soLuongNguoiLon;
        data["soLuongTreEm"] = this.soLuongTreEm;
        data["diemDen"] = this.diemDen;
        data["gioDon"] = this.gioDon ? this.gioDon.toString() : <any>undefined;
        if (Array.isArray(this.listChiTiet)) {
            data["listChiTiet"] = [];
            for (let item of this.listChiTiet)
                data["listChiTiet"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrUpdateDichVuBookingTourDto {
    bookingId: number;
    tourId: number | undefined;
    tenTour: string | undefined;
    ngayBatDau: DateTime | undefined;
    soLuongNguoiLon: number | undefined;
    soLuongTreEm: number | undefined;
    diemDen: string | undefined;
    gioDon: DateTime | undefined;
    listChiTiet: CrudChiTietDichVuBookingTour[] | undefined;
    id: number;
}

export class CreateOrUpdateBookingRequest implements ICreateOrUpdateBookingRequest {
    booking!: CreateOrUpdatThongTinBookingDto;
    tour!: CreateOrUpdateDichVuBookingTourDto;
    id!: number;

    constructor(data?: ICreateOrUpdateBookingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.booking = _data["booking"] ? CreateOrUpdatThongTinBookingDto.fromJS(_data["booking"]) : <any>undefined;
            this.tour = _data["tour"] ? CreateOrUpdateDichVuBookingTourDto.fromJS(_data["tour"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateBookingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateBookingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["booking"] = this.booking ? this.booking.toJSON() : <any>undefined;
        data["tour"] = this.tour ? this.tour.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrUpdateBookingRequest {
    booking: CreateOrUpdatThongTinBookingDto;
    tour: CreateOrUpdateDichVuBookingTourDto;
    id: number;
}

export class Int64CommonResultDto implements IInt64CommonResultDto {
    dataResult!: number;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: IInt64CommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"];
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): Int64CommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64CommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface IInt64CommonResultDto {
    dataResult: number;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class GetBookingByIdRequest implements IGetBookingByIdRequest {
    id!: number;

    constructor(data?: IGetBookingByIdRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetBookingByIdRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetBookingByIdRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IGetBookingByIdRequest {
    id: number;
}

export class ChiTietDichVuBookingTourDto implements IChiTietDichVuBookingTourDto {
    bookingId!: number;
    bookingTourId!: number;
    loaiDoTuoi!: string | undefined;
    giaNett!: number;
    giaBan!: number;
    soLuong!: number;
    thanhTien!: number;
    id!: number;

    constructor(data?: IChiTietDichVuBookingTourDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookingId = _data["bookingId"];
            this.bookingTourId = _data["bookingTourId"];
            this.loaiDoTuoi = _data["loaiDoTuoi"];
            this.giaNett = _data["giaNett"];
            this.giaBan = _data["giaBan"];
            this.soLuong = _data["soLuong"];
            this.thanhTien = _data["thanhTien"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChiTietDichVuBookingTourDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChiTietDichVuBookingTourDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookingId"] = this.bookingId;
        data["bookingTourId"] = this.bookingTourId;
        data["loaiDoTuoi"] = this.loaiDoTuoi;
        data["giaNett"] = this.giaNett;
        data["giaBan"] = this.giaBan;
        data["soLuong"] = this.soLuong;
        data["thanhTien"] = this.thanhTien;
        data["id"] = this.id;
        return data;
    }
}

export interface IChiTietDichVuBookingTourDto {
    bookingId: number;
    bookingTourId: number;
    loaiDoTuoi: string | undefined;
    giaNett: number;
    giaBan: number;
    soLuong: number;
    thanhTien: number;
    id: number;
}

export class DichVuBookingTourDto implements IDichVuBookingTourDto {
    bookingId!: number;
    tourId!: number | undefined;
    tenTour!: string | undefined;
    ngayBatDau!: DateTime | undefined;
    soNgay!: number;
    soDem!: number;
    soLuongNguoiLon!: number | undefined;
    soLuongTreEm!: number | undefined;
    diemDen!: string | undefined;
    gioDon!: DateTime | undefined;
    listChiTiet!: ChiTietDichVuBookingTourDto[] | undefined;
    id!: number;

    constructor(data?: IDichVuBookingTourDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookingId = _data["bookingId"];
            this.tourId = _data["tourId"];
            this.tenTour = _data["tenTour"];
            this.ngayBatDau = _data["ngayBatDau"] ? DateTime.fromISO(_data["ngayBatDau"].toString()) : <any>undefined;
            this.soNgay = _data["soNgay"];
            this.soDem = _data["soDem"];
            this.soLuongNguoiLon = _data["soLuongNguoiLon"];
            this.soLuongTreEm = _data["soLuongTreEm"];
            this.diemDen = _data["diemDen"];
            this.gioDon = _data["gioDon"] ? DateTime.fromISO(_data["gioDon"].toString()) : <any>undefined;
            if (Array.isArray(_data["listChiTiet"])) {
                this.listChiTiet = [] as any;
                for (let item of _data["listChiTiet"])
                    this.listChiTiet!.push(ChiTietDichVuBookingTourDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DichVuBookingTourDto {
        data = typeof data === 'object' ? data : {};
        let result = new DichVuBookingTourDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookingId"] = this.bookingId;
        data["tourId"] = this.tourId;
        data["tenTour"] = this.tenTour;
        data["ngayBatDau"] = this.ngayBatDau ? this.ngayBatDau.toString() : <any>undefined;
        data["soNgay"] = this.soNgay;
        data["soDem"] = this.soDem;
        data["soLuongNguoiLon"] = this.soLuongNguoiLon;
        data["soLuongTreEm"] = this.soLuongTreEm;
        data["diemDen"] = this.diemDen;
        data["gioDon"] = this.gioDon ? this.gioDon.toString() : <any>undefined;
        if (Array.isArray(this.listChiTiet)) {
            data["listChiTiet"] = [];
            for (let item of this.listChiTiet)
                data["listChiTiet"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IDichVuBookingTourDto {
    bookingId: number;
    tourId: number | undefined;
    tenTour: string | undefined;
    ngayBatDau: DateTime | undefined;
    soNgay: number;
    soDem: number;
    soLuongNguoiLon: number | undefined;
    soLuongTreEm: number | undefined;
    diemDen: string | undefined;
    gioDon: DateTime | undefined;
    listChiTiet: ChiTietDichVuBookingTourDto[] | undefined;
    id: number;
}

export class BookingDto implements IBookingDto {
    thongTinChung!: ThongTinChungBookingDto;
    dichVuBookingTour!: DichVuBookingTourDto;
    id!: number;

    constructor(data?: IBookingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thongTinChung = _data["thongTinChung"] ? ThongTinChungBookingDto.fromJS(_data["thongTinChung"]) : <any>undefined;
            this.dichVuBookingTour = _data["dichVuBookingTour"] ? DichVuBookingTourDto.fromJS(_data["dichVuBookingTour"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BookingDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thongTinChung"] = this.thongTinChung ? this.thongTinChung.toJSON() : <any>undefined;
        data["dichVuBookingTour"] = this.dichVuBookingTour ? this.dichVuBookingTour.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IBookingDto {
    thongTinChung: ThongTinChungBookingDto;
    dichVuBookingTour: DichVuBookingTourDto;
    id: number;
}

export class BookingDtoCommonResultDto implements IBookingDtoCommonResultDto {
    dataResult!: BookingDto;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: IBookingDtoCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"] ? BookingDto.fromJS(_data["dataResult"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): BookingDtoCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookingDtoCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface IBookingDtoCommonResultDto {
    dataResult: BookingDto;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class PagingListThanhVienDoanRequest implements IPagingListThanhVienDoanRequest {
    bookingId!: number;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingListThanhVienDoanRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookingId = _data["bookingId"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingListThanhVienDoanRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingListThanhVienDoanRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookingId"] = this.bookingId;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingListThanhVienDoanRequest {
    bookingId: number;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class ChiTietThanhVienDoanDto implements IChiTietThanhVienDoanDto {
    bookingId!: number;
    ten!: string | undefined;
    email!: string | undefined;
    soDienThoai!: string | undefined;
    quocTichId!: number;
    vaiTroCode!: string | undefined;
    id!: number;

    constructor(data?: IChiTietThanhVienDoanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookingId = _data["bookingId"];
            this.ten = _data["ten"];
            this.email = _data["email"];
            this.soDienThoai = _data["soDienThoai"];
            this.quocTichId = _data["quocTichId"];
            this.vaiTroCode = _data["vaiTroCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChiTietThanhVienDoanDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChiTietThanhVienDoanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookingId"] = this.bookingId;
        data["ten"] = this.ten;
        data["email"] = this.email;
        data["soDienThoai"] = this.soDienThoai;
        data["quocTichId"] = this.quocTichId;
        data["vaiTroCode"] = this.vaiTroCode;
        data["id"] = this.id;
        return data;
    }
}

export interface IChiTietThanhVienDoanDto {
    bookingId: number;
    ten: string | undefined;
    email: string | undefined;
    soDienThoai: string | undefined;
    quocTichId: number;
    vaiTroCode: string | undefined;
    id: number;
}

export class ChiTietThanhVienDoanDtoPagedResultDto implements IChiTietThanhVienDoanDtoPagedResultDto {
    totalCount!: number;
    items!: ChiTietThanhVienDoanDto[] | undefined;

    constructor(data?: IChiTietThanhVienDoanDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChiTietThanhVienDoanDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChiTietThanhVienDoanDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChiTietThanhVienDoanDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChiTietThanhVienDoanDtoPagedResultDto {
    totalCount: number;
    items: ChiTietThanhVienDoanDto[] | undefined;
}

export class CreateOrUpdateThanhVienDoanRequest implements ICreateOrUpdateThanhVienDoanRequest {
    bookingId!: number;
    ten!: string | undefined;
    email!: string | undefined;
    soDienThoai!: string | undefined;
    quocTichId!: number;
    vaiTroCode!: string | undefined;
    id!: number;

    constructor(data?: ICreateOrUpdateThanhVienDoanRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookingId = _data["bookingId"];
            this.ten = _data["ten"];
            this.email = _data["email"];
            this.soDienThoai = _data["soDienThoai"];
            this.quocTichId = _data["quocTichId"];
            this.vaiTroCode = _data["vaiTroCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateThanhVienDoanRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateThanhVienDoanRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookingId"] = this.bookingId;
        data["ten"] = this.ten;
        data["email"] = this.email;
        data["soDienThoai"] = this.soDienThoai;
        data["quocTichId"] = this.quocTichId;
        data["vaiTroCode"] = this.vaiTroCode;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrUpdateThanhVienDoanRequest {
    bookingId: number;
    ten: string | undefined;
    email: string | undefined;
    soDienThoai: string | undefined;
    quocTichId: number;
    vaiTroCode: string | undefined;
    id: number;
}

export class PagingDichVuLeRequest implements IPagingDichVuLeRequest {
    bookingid!: number;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingDichVuLeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookingid = _data["bookingid"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingDichVuLeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingDichVuLeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookingid"] = this.bookingid;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingDichVuLeRequest {
    bookingid: number;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class ChiTietDichVuLeBookingDto implements IChiTietDichVuLeBookingDto {
    bookingId!: number | undefined;
    nhaCungCapCode!: string | undefined;
    nhaCungCapDisplay!: string | undefined;
    dichVuId!: number | undefined;
    tenDichVu!: string | undefined;
    nhaCungCapId!: number | undefined;
    tenNhaCungCap!: string | undefined;
    email!: string | undefined;
    soDienThoai!: string | undefined;
    donGia!: number | undefined;
    soLuong!: number | undefined;
    khoangKhachCode!: string | undefined;
    thanhTien!: number | undefined;
    ghiChu!: string | undefined;
    trangThai!: number;
    ngaythu!: number;
    phuongThucCode!: string | undefined;
    loaiXe!: string | undefined;
    soChoNgoi!: string | undefined;
    id!: number;

    constructor(data?: IChiTietDichVuLeBookingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookingId = _data["bookingId"];
            this.nhaCungCapCode = _data["nhaCungCapCode"];
            this.nhaCungCapDisplay = _data["nhaCungCapDisplay"];
            this.dichVuId = _data["dichVuId"];
            this.tenDichVu = _data["tenDichVu"];
            this.nhaCungCapId = _data["nhaCungCapId"];
            this.tenNhaCungCap = _data["tenNhaCungCap"];
            this.email = _data["email"];
            this.soDienThoai = _data["soDienThoai"];
            this.donGia = _data["donGia"];
            this.soLuong = _data["soLuong"];
            this.khoangKhachCode = _data["khoangKhachCode"];
            this.thanhTien = _data["thanhTien"];
            this.ghiChu = _data["ghiChu"];
            this.trangThai = _data["trangThai"];
            this.ngaythu = _data["ngaythu"];
            this.phuongThucCode = _data["phuongThucCode"];
            this.loaiXe = _data["loaiXe"];
            this.soChoNgoi = _data["soChoNgoi"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChiTietDichVuLeBookingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChiTietDichVuLeBookingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookingId"] = this.bookingId;
        data["nhaCungCapCode"] = this.nhaCungCapCode;
        data["nhaCungCapDisplay"] = this.nhaCungCapDisplay;
        data["dichVuId"] = this.dichVuId;
        data["tenDichVu"] = this.tenDichVu;
        data["nhaCungCapId"] = this.nhaCungCapId;
        data["tenNhaCungCap"] = this.tenNhaCungCap;
        data["email"] = this.email;
        data["soDienThoai"] = this.soDienThoai;
        data["donGia"] = this.donGia;
        data["soLuong"] = this.soLuong;
        data["khoangKhachCode"] = this.khoangKhachCode;
        data["thanhTien"] = this.thanhTien;
        data["ghiChu"] = this.ghiChu;
        data["trangThai"] = this.trangThai;
        data["ngaythu"] = this.ngaythu;
        data["phuongThucCode"] = this.phuongThucCode;
        data["loaiXe"] = this.loaiXe;
        data["soChoNgoi"] = this.soChoNgoi;
        data["id"] = this.id;
        return data;
    }
}

export interface IChiTietDichVuLeBookingDto {
    bookingId: number | undefined;
    nhaCungCapCode: string | undefined;
    nhaCungCapDisplay: string | undefined;
    dichVuId: number | undefined;
    tenDichVu: string | undefined;
    nhaCungCapId: number | undefined;
    tenNhaCungCap: string | undefined;
    email: string | undefined;
    soDienThoai: string | undefined;
    donGia: number | undefined;
    soLuong: number | undefined;
    khoangKhachCode: string | undefined;
    thanhTien: number | undefined;
    ghiChu: string | undefined;
    trangThai: number;
    ngaythu: number;
    phuongThucCode: string | undefined;
    loaiXe: string | undefined;
    soChoNgoi: string | undefined;
    id: number;
}

export class ChiTietDichVuLeBookingDtoPagedResultDto implements IChiTietDichVuLeBookingDtoPagedResultDto {
    totalCount!: number;
    items!: ChiTietDichVuLeBookingDto[] | undefined;

    constructor(data?: IChiTietDichVuLeBookingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChiTietDichVuLeBookingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChiTietDichVuLeBookingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChiTietDichVuLeBookingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChiTietDichVuLeBookingDtoPagedResultDto {
    totalCount: number;
    items: ChiTietDichVuLeBookingDto[] | undefined;
}

export class CreateOrUpdateDichVuLeRequest implements ICreateOrUpdateDichVuLeRequest {
    nhaCungCapCode!: string | undefined;
    bookingId!: number | undefined;
    dichVuId!: number | undefined;
    nhaCungCapId!: number | undefined;
    tenDichVu!: string | undefined;
    soLuong!: number | undefined;
    donGia!: number | undefined;
    thanhTien!: number | undefined;
    ghiChu!: string | undefined;
    trangThai!: number;
    id!: number;

    constructor(data?: ICreateOrUpdateDichVuLeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCapCode = _data["nhaCungCapCode"];
            this.bookingId = _data["bookingId"];
            this.dichVuId = _data["dichVuId"];
            this.nhaCungCapId = _data["nhaCungCapId"];
            this.tenDichVu = _data["tenDichVu"];
            this.soLuong = _data["soLuong"];
            this.donGia = _data["donGia"];
            this.thanhTien = _data["thanhTien"];
            this.ghiChu = _data["ghiChu"];
            this.trangThai = _data["trangThai"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateDichVuLeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateDichVuLeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCapCode"] = this.nhaCungCapCode;
        data["bookingId"] = this.bookingId;
        data["dichVuId"] = this.dichVuId;
        data["nhaCungCapId"] = this.nhaCungCapId;
        data["tenDichVu"] = this.tenDichVu;
        data["soLuong"] = this.soLuong;
        data["donGia"] = this.donGia;
        data["thanhTien"] = this.thanhTien;
        data["ghiChu"] = this.ghiChu;
        data["trangThai"] = this.trangThai;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrUpdateDichVuLeRequest {
    nhaCungCapCode: string | undefined;
    bookingId: number | undefined;
    dichVuId: number | undefined;
    nhaCungCapId: number | undefined;
    tenDichVu: string | undefined;
    soLuong: number | undefined;
    donGia: number | undefined;
    thanhTien: number | undefined;
    ghiChu: string | undefined;
    trangThai: number;
    id: number;
}

export class BooleanCommonResultDto implements IBooleanCommonResultDto {
    dataResult!: boolean;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: IBooleanCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"];
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): BooleanCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface IBooleanCommonResultDto {
    dataResult: boolean;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class SendEmailLienHeNCCRequest implements ISendEmailLienHeNCCRequest {
    templateEmail!: string | undefined;
    email!: string | undefined;
    bookingId!: number;

    constructor(data?: ISendEmailLienHeNCCRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateEmail = _data["templateEmail"];
            this.email = _data["email"];
            this.bookingId = _data["bookingId"];
        }
    }

    static fromJS(data: any): SendEmailLienHeNCCRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailLienHeNCCRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateEmail"] = this.templateEmail;
        data["email"] = this.email;
        data["bookingId"] = this.bookingId;
        return data;
    }
}

export interface ISendEmailLienHeNCCRequest {
    templateEmail: string | undefined;
    email: string | undefined;
    bookingId: number;
}

export class HuyBookingRequest implements IHuyBookingRequest {
    dto!: ThongTinChungBookingDto;
    isQuaHan!: boolean;

    constructor(data?: IHuyBookingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dto = _data["dto"] ? ThongTinChungBookingDto.fromJS(_data["dto"]) : <any>undefined;
            this.isQuaHan = _data["isQuaHan"];
        }
    }

    static fromJS(data: any): HuyBookingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new HuyBookingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dto"] = this.dto ? this.dto.toJSON() : <any>undefined;
        data["isQuaHan"] = this.isQuaHan;
        return data;
    }
}

export interface IHuyBookingRequest {
    dto: ThongTinChungBookingDto;
    isQuaHan: boolean;
}

export class PagingCodeSystemRequests implements IPagingCodeSystemRequests {
    parentCode!: string | undefined;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingCodeSystemRequests) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentCode = _data["parentCode"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingCodeSystemRequests {
        data = typeof data === 'object' ? data : {};
        let result = new PagingCodeSystemRequests();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentCode"] = this.parentCode;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingCodeSystemRequests {
    parentCode: string | undefined;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class CodeSystemDto implements ICodeSystemDto {
    code!: string | undefined;
    display!: string | undefined;
    parentId!: number | undefined;
    parentCode!: string | undefined;
    ngayTao!: string | undefined;
    loaiDanhMuc!: string | undefined;
    id!: number;

    constructor(data?: ICodeSystemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.display = _data["display"];
            this.parentId = _data["parentId"];
            this.parentCode = _data["parentCode"];
            this.ngayTao = _data["ngayTao"];
            this.loaiDanhMuc = _data["loaiDanhMuc"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CodeSystemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CodeSystemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["display"] = this.display;
        data["parentId"] = this.parentId;
        data["parentCode"] = this.parentCode;
        data["ngayTao"] = this.ngayTao;
        data["loaiDanhMuc"] = this.loaiDanhMuc;
        data["id"] = this.id;
        return data;
    }
}

export interface ICodeSystemDto {
    code: string | undefined;
    display: string | undefined;
    parentId: number | undefined;
    parentCode: string | undefined;
    ngayTao: string | undefined;
    loaiDanhMuc: string | undefined;
    id: number;
}

export class CodeSystemDtoPagedResultDto implements ICodeSystemDtoPagedResultDto {
    totalCount!: number;
    items!: CodeSystemDto[] | undefined;

    constructor(data?: ICodeSystemDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CodeSystemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CodeSystemDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CodeSystemDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICodeSystemDtoPagedResultDto {
    totalCount: number;
    items: CodeSystemDto[] | undefined;
}

export class ExportExcelCodeSystemRequest implements IExportExcelCodeSystemRequest {
    filterInput!: PagingCodeSystemRequests;
    parentCode!: string | undefined;

    constructor(data?: IExportExcelCodeSystemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filterInput = _data["filterInput"] ? PagingCodeSystemRequests.fromJS(_data["filterInput"]) : <any>undefined;
            this.parentCode = _data["parentCode"];
        }
    }

    static fromJS(data: any): ExportExcelCodeSystemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExportExcelCodeSystemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterInput"] = this.filterInput ? this.filterInput.toJSON() : <any>undefined;
        data["parentCode"] = this.parentCode;
        return data;
    }
}

export interface IExportExcelCodeSystemRequest {
    filterInput: PagingCodeSystemRequests;
    parentCode: string | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string | undefined;
    fileToken!: string;
    fileBytes!: string | undefined;
    fileBase64!: string | undefined;
    isSuccess!: boolean;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileToken = _data["fileToken"];
            this.fileBytes = _data["fileBytes"];
            this.fileBase64 = _data["fileBase64"];
            this.isSuccess = _data["isSuccess"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        data["fileBytes"] = this.fileBytes;
        data["fileBase64"] = this.fileBase64;
        data["isSuccess"] = this.isSuccess;
        return data;
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;
    fileBytes: string | undefined;
    fileBase64: string | undefined;
    isSuccess: boolean;
}

export class DownloadFTCodeSystemRequest implements IDownloadFTCodeSystemRequest {
    display!: string | undefined;

    constructor(data?: IDownloadFTCodeSystemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.display = _data["display"];
        }
    }

    static fromJS(data: any): DownloadFTCodeSystemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadFTCodeSystemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["display"] = this.display;
        return data;
    }
}

export interface IDownloadFTCodeSystemRequest {
    display: string | undefined;
}

export class CheckValidImportExcelCodeSystemDto implements ICheckValidImportExcelCodeSystemDto {
    display!: string | undefined;
    code!: string | undefined;
    isValid!: boolean;
    parentCode!: string | undefined;
    parentId!: number | undefined;
    ngayTao!: string | undefined;
    id!: number;
    listError!: string[] | undefined;

    constructor(data?: ICheckValidImportExcelCodeSystemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.display = _data["display"];
            this.code = _data["code"];
            this.isValid = _data["isValid"];
            this.parentCode = _data["parentCode"];
            this.parentId = _data["parentId"];
            this.ngayTao = _data["ngayTao"];
            this.id = _data["id"];
            if (Array.isArray(_data["listError"])) {
                this.listError = [] as any;
                for (let item of _data["listError"])
                    this.listError!.push(item);
            }
        }
    }

    static fromJS(data: any): CheckValidImportExcelCodeSystemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckValidImportExcelCodeSystemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["display"] = this.display;
        data["code"] = this.code;
        data["isValid"] = this.isValid;
        data["parentCode"] = this.parentCode;
        data["parentId"] = this.parentId;
        data["ngayTao"] = this.ngayTao;
        data["id"] = this.id;
        if (Array.isArray(this.listError)) {
            data["listError"] = [];
            for (let item of this.listError)
                data["listError"].push(item);
        }
        return data;
    }
}

export interface ICheckValidImportExcelCodeSystemDto {
    display: string | undefined;
    code: string | undefined;
    isValid: boolean;
    parentCode: string | undefined;
    parentId: number | undefined;
    ngayTao: string | undefined;
    id: number;
    listError: string[] | undefined;
}

export class CheckValidImportExcelCodeSystemRequest implements ICheckValidImportExcelCodeSystemRequest {
    input!: CheckValidImportExcelCodeSystemDto[] | undefined;
    parentCode!: string | undefined;

    constructor(data?: ICheckValidImportExcelCodeSystemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["input"])) {
                this.input = [] as any;
                for (let item of _data["input"])
                    this.input!.push(CheckValidImportExcelCodeSystemDto.fromJS(item));
            }
            this.parentCode = _data["parentCode"];
        }
    }

    static fromJS(data: any): CheckValidImportExcelCodeSystemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CheckValidImportExcelCodeSystemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.input)) {
            data["input"] = [];
            for (let item of this.input)
                data["input"].push(item.toJSON());
        }
        data["parentCode"] = this.parentCode;
        return data;
    }
}

export interface ICheckValidImportExcelCodeSystemRequest {
    input: CheckValidImportExcelCodeSystemDto[] | undefined;
    parentCode: string | undefined;
}

export class UploadExcelCodeSystemRequest implements IUploadExcelCodeSystemRequest {
    listData!: CheckValidImportExcelCodeSystemDto[] | undefined;
    parentCode!: string | undefined;

    constructor(data?: IUploadExcelCodeSystemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listData"])) {
                this.listData = [] as any;
                for (let item of _data["listData"])
                    this.listData!.push(CheckValidImportExcelCodeSystemDto.fromJS(item));
            }
            this.parentCode = _data["parentCode"];
        }
    }

    static fromJS(data: any): UploadExcelCodeSystemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UploadExcelCodeSystemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listData)) {
            data["listData"] = [];
            for (let item of this.listData)
                data["listData"].push(item.toJSON());
        }
        data["parentCode"] = this.parentCode;
        return data;
    }
}

export interface IUploadExcelCodeSystemRequest {
    listData: CheckValidImportExcelCodeSystemDto[] | undefined;
    parentCode: string | undefined;
}

export class CodeSystemDtoCommonResultDto implements ICodeSystemDtoCommonResultDto {
    dataResult!: CodeSystemDto;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: ICodeSystemDtoCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"] ? CodeSystemDto.fromJS(_data["dataResult"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): CodeSystemDtoCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CodeSystemDtoCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface ICodeSystemDtoCommonResultDto {
    dataResult: CodeSystemDto;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class CodeSystemMapEntity implements ICodeSystemMapEntity {
    sourceId!: number;
    destinationId!: number;
    codeType!: string | undefined;
    readonly id!: number;

    constructor(data?: ICodeSystemMapEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceId = _data["sourceId"];
            this.destinationId = _data["destinationId"];
            this.codeType = _data["codeType"];
            (<any>this).id = _data["id"];
        }
    }

    static fromJS(data: any): CodeSystemMapEntity {
        data = typeof data === 'object' ? data : {};
        let result = new CodeSystemMapEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceId"] = this.sourceId;
        data["destinationId"] = this.destinationId;
        data["codeType"] = this.codeType;
        data["id"] = this.id;
        return data;
    }
}

export interface ICodeSystemMapEntity {
    sourceId: number;
    destinationId: number;
    codeType: string | undefined;
    id: number;
}

export class ComboBoxDto implements IComboBoxDto {
    value!: any | undefined;
    displayText!: string | undefined;
    hideText!: string | undefined;
    isActive!: boolean;
    data!: any | undefined;

    constructor(data?: IComboBoxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.hideText = _data["hideText"];
            this.isActive = _data["isActive"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): ComboBoxDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboBoxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["hideText"] = this.hideText;
        data["isActive"] = this.isActive;
        data["data"] = this.data;
        return data;
    }
}

export interface IComboBoxDto {
    value: any | undefined;
    displayText: string | undefined;
    hideText: string | undefined;
    isActive: boolean;
    data: any | undefined;
}

export class HuyenComboboxRequest implements IHuyenComboboxRequest {
    tinhId!: string | undefined;

    constructor(data?: IHuyenComboboxRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tinhId = _data["tinhId"];
        }
    }

    static fromJS(data: any): HuyenComboboxRequest {
        data = typeof data === 'object' ? data : {};
        let result = new HuyenComboboxRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tinhId"] = this.tinhId;
        return data;
    }
}

export interface IHuyenComboboxRequest {
    tinhId: string | undefined;
}

export class XaComboboxRequest implements IXaComboboxRequest {
    huyenId!: string | undefined;

    constructor(data?: IXaComboboxRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.huyenId = _data["huyenId"];
        }
    }

    static fromJS(data: any): XaComboboxRequest {
        data = typeof data === 'object' ? data : {};
        let result = new XaComboboxRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["huyenId"] = this.huyenId;
        return data;
    }
}

export interface IXaComboboxRequest {
    huyenId: string | undefined;
}

export enum PHAN_VUNG_TINH {
    TAY_NGUYEN = 1,
    DUYEN_HAI_MIEN_TRUNG = 2,
    DONG_NAM_BO = 3,
    KHAC = 4,
}

export class PHAN_VUNG_TINHItemObj implements IPHAN_VUNG_TINHItemObj {
    id!: PHAN_VUNG_TINH;
    name!: string | undefined;
    totalCount!: number | undefined;

    constructor(data?: IPHAN_VUNG_TINHItemObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PHAN_VUNG_TINHItemObj {
        data = typeof data === 'object' ? data : {};
        let result = new PHAN_VUNG_TINHItemObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPHAN_VUNG_TINHItemObj {
    id: PHAN_VUNG_TINH;
    name: string | undefined;
    totalCount: number | undefined;
}

export enum TRANG_THAI_BOOKING {
    DANG_XU_LY = 1,
    CHO_DIEU_HANH = 2,
    DIEU_HANH = 3,
}

export class TRANG_THAI_BOOKINGItemObj implements ITRANG_THAI_BOOKINGItemObj {
    id!: TRANG_THAI_BOOKING;
    name!: string | undefined;
    totalCount!: number | undefined;

    constructor(data?: ITRANG_THAI_BOOKINGItemObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TRANG_THAI_BOOKINGItemObj {
        data = typeof data === 'object' ? data : {};
        let result = new TRANG_THAI_BOOKINGItemObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ITRANG_THAI_BOOKINGItemObj {
    id: TRANG_THAI_BOOKING;
    name: string | undefined;
    totalCount: number | undefined;
}

export class GetComboDataFromDataBaseInputDto implements IGetComboDataFromDataBaseInputDto {
    tableName!: string | undefined;
    cascaderId!: number | undefined;
    cascaderCode!: string | undefined;
    cascaderMa!: string | undefined;
    trangThai!: number | undefined;

    constructor(data?: IGetComboDataFromDataBaseInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tableName = _data["tableName"];
            this.cascaderId = _data["cascaderId"];
            this.cascaderCode = _data["cascaderCode"];
            this.cascaderMa = _data["cascaderMa"];
            this.trangThai = _data["trangThai"];
        }
    }

    static fromJS(data: any): GetComboDataFromDataBaseInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetComboDataFromDataBaseInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tableName"] = this.tableName;
        data["cascaderId"] = this.cascaderId;
        data["cascaderCode"] = this.cascaderCode;
        data["cascaderMa"] = this.cascaderMa;
        data["trangThai"] = this.trangThai;
        return data;
    }
}

export interface IGetComboDataFromDataBaseInputDto {
    tableName: string | undefined;
    cascaderId: number | undefined;
    cascaderCode: string | undefined;
    cascaderMa: string | undefined;
    trangThai: number | undefined;
}

export enum LEVEL {
    ADMIN = 0,
}

export class CommonEnumDto implements ICommonEnumDto {
    level!: LEVEL;

    constructor(data?: ICommonEnumDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["level"];
        }
    }

    static fromJS(data: any): CommonEnumDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonEnumDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        return data;
    }
}

export interface ICommonEnumDto {
    level: LEVEL;
}

export class PagingConfigSystemRequest implements IPagingConfigSystemRequest {
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingConfigSystemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingConfigSystemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingConfigSystemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingConfigSystemRequest {
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class ConfigSystemDto implements IConfigSystemDto {
    type!: number;
    ma!: string | undefined;
    giaTri!: string | undefined;
    moTa!: string | undefined;
    tuNgay!: DateTime | undefined;
    denNgay!: DateTime | undefined;
    id!: number;

    constructor(data?: IConfigSystemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.ma = _data["ma"];
            this.giaTri = _data["giaTri"];
            this.moTa = _data["moTa"];
            this.tuNgay = _data["tuNgay"] ? DateTime.fromISO(_data["tuNgay"].toString()) : <any>undefined;
            this.denNgay = _data["denNgay"] ? DateTime.fromISO(_data["denNgay"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ConfigSystemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigSystemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["ma"] = this.ma;
        data["giaTri"] = this.giaTri;
        data["moTa"] = this.moTa;
        data["tuNgay"] = this.tuNgay ? this.tuNgay.toString() : <any>undefined;
        data["denNgay"] = this.denNgay ? this.denNgay.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IConfigSystemDto {
    type: number;
    ma: string | undefined;
    giaTri: string | undefined;
    moTa: string | undefined;
    tuNgay: DateTime | undefined;
    denNgay: DateTime | undefined;
    id: number;
}

export class ConfigSystemDtoPagedResultDto implements IConfigSystemDtoPagedResultDto {
    totalCount!: number;
    items!: ConfigSystemDto[] | undefined;

    constructor(data?: IConfigSystemDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ConfigSystemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConfigSystemDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigSystemDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IConfigSystemDtoPagedResultDto {
    totalCount: number;
    items: ConfigSystemDto[] | undefined;
}

export class ConfigSystemDtoCommonResultDto implements IConfigSystemDtoCommonResultDto {
    dataResult!: ConfigSystemDto;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: IConfigSystemDtoCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"] ? ConfigSystemDto.fromJS(_data["dataResult"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): ConfigSystemDtoCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigSystemDtoCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface IConfigSystemDtoCommonResultDto {
    dataResult: ConfigSystemDto;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class CheckValidImportExcelDanhMucHuyenDto implements ICheckValidImportExcelDanhMucHuyenDto {
    id!: string | undefined;
    ten!: string | undefined;
    cap!: string | undefined;
    tenEn!: string | undefined;
    tinhId!: string | undefined;
    tenTinh!: string | undefined;
    isValid!: boolean;
    isActive!: boolean;
    listError!: string[] | undefined;

    constructor(data?: ICheckValidImportExcelDanhMucHuyenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ten = _data["ten"];
            this.cap = _data["cap"];
            this.tenEn = _data["tenEn"];
            this.tinhId = _data["tinhId"];
            this.tenTinh = _data["tenTinh"];
            this.isValid = _data["isValid"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["listError"])) {
                this.listError = [] as any;
                for (let item of _data["listError"])
                    this.listError!.push(item);
            }
        }
    }

    static fromJS(data: any): CheckValidImportExcelDanhMucHuyenDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckValidImportExcelDanhMucHuyenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ten"] = this.ten;
        data["cap"] = this.cap;
        data["tenEn"] = this.tenEn;
        data["tinhId"] = this.tinhId;
        data["tenTinh"] = this.tenTinh;
        data["isValid"] = this.isValid;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.listError)) {
            data["listError"] = [];
            for (let item of this.listError)
                data["listError"].push(item);
        }
        return data;
    }
}

export interface ICheckValidImportExcelDanhMucHuyenDto {
    id: string | undefined;
    ten: string | undefined;
    cap: string | undefined;
    tenEn: string | undefined;
    tinhId: string | undefined;
    tenTinh: string | undefined;
    isValid: boolean;
    isActive: boolean;
    listError: string[] | undefined;
}

export class CheckValidImportExcelDanhMucHuyenRequest implements ICheckValidImportExcelDanhMucHuyenRequest {
    input!: CheckValidImportExcelDanhMucHuyenDto[] | undefined;

    constructor(data?: ICheckValidImportExcelDanhMucHuyenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["input"])) {
                this.input = [] as any;
                for (let item of _data["input"])
                    this.input!.push(CheckValidImportExcelDanhMucHuyenDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CheckValidImportExcelDanhMucHuyenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CheckValidImportExcelDanhMucHuyenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.input)) {
            data["input"] = [];
            for (let item of this.input)
                data["input"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICheckValidImportExcelDanhMucHuyenRequest {
    input: CheckValidImportExcelDanhMucHuyenDto[] | undefined;
}

export class UploadExcelDanhMucHuyenRequest implements IUploadExcelDanhMucHuyenRequest {
    listData!: CheckValidImportExcelDanhMucHuyenDto[] | undefined;

    constructor(data?: IUploadExcelDanhMucHuyenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listData"])) {
                this.listData = [] as any;
                for (let item of _data["listData"])
                    this.listData!.push(CheckValidImportExcelDanhMucHuyenDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UploadExcelDanhMucHuyenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UploadExcelDanhMucHuyenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listData)) {
            data["listData"] = [];
            for (let item of this.listData)
                data["listData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUploadExcelDanhMucHuyenRequest {
    listData: CheckValidImportExcelDanhMucHuyenDto[] | undefined;
}

export class PagingDanhMucHuyenRequest implements IPagingDanhMucHuyenRequest {
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingDanhMucHuyenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingDanhMucHuyenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingDanhMucHuyenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingDanhMucHuyenRequest {
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class ExportDanhMucHuyenRequest implements IExportDanhMucHuyenRequest {
    filterInput!: PagingDanhMucHuyenRequest;

    constructor(data?: IExportDanhMucHuyenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filterInput = _data["filterInput"] ? PagingDanhMucHuyenRequest.fromJS(_data["filterInput"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExportDanhMucHuyenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExportDanhMucHuyenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterInput"] = this.filterInput ? this.filterInput.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExportDanhMucHuyenRequest {
    filterInput: PagingDanhMucHuyenRequest;
}

export class HuyenDto implements IHuyenDto {
    ten!: string;
    cap!: string | undefined;
    tenEn!: string | undefined;
    tinhId!: string;
    isActive!: boolean;
    tenTinh!: string | undefined;
    id!: string | undefined;

    constructor(data?: IHuyenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.cap = _data["cap"];
            this.tenEn = _data["tenEn"];
            this.tinhId = _data["tinhId"];
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : true;
            this.tenTinh = _data["tenTinh"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HuyenDto {
        data = typeof data === 'object' ? data : {};
        let result = new HuyenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["cap"] = this.cap;
        data["tenEn"] = this.tenEn;
        data["tinhId"] = this.tinhId;
        data["isActive"] = this.isActive;
        data["tenTinh"] = this.tenTinh;
        data["id"] = this.id;
        return data;
    }
}

export interface IHuyenDto {
    ten: string;
    cap: string | undefined;
    tenEn: string | undefined;
    tinhId: string;
    isActive: boolean;
    tenTinh: string | undefined;
    id: string | undefined;
}

export class HuyenDtoCommonResultDto implements IHuyenDtoCommonResultDto {
    dataResult!: HuyenDto;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: IHuyenDtoCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"] ? HuyenDto.fromJS(_data["dataResult"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): HuyenDtoCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HuyenDtoCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface IHuyenDtoCommonResultDto {
    dataResult: HuyenDto;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class HuyenPagedRequestDto implements IHuyenPagedRequestDto {
    tinhId!: string | undefined;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IHuyenPagedRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tinhId = _data["tinhId"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): HuyenPagedRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new HuyenPagedRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tinhId"] = this.tinhId;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IHuyenPagedRequestDto {
    tinhId: string | undefined;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class HuyenDtoPagedResultDto implements IHuyenDtoPagedResultDto {
    totalCount!: number;
    items!: HuyenDto[] | undefined;

    constructor(data?: IHuyenDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HuyenDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HuyenDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HuyenDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHuyenDtoPagedResultDto {
    totalCount: number;
    items: HuyenDto[] | undefined;
}

export class StringCommonResultDto implements IStringCommonResultDto {
    dataResult!: string | undefined;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: IStringCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"];
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): StringCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StringCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface IStringCommonResultDto {
    dataResult: string | undefined;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class PagingQuocTichRequest implements IPagingQuocTichRequest {
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingQuocTichRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingQuocTichRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingQuocTichRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingQuocTichRequest {
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class QuocTichDto implements IQuocTichDto {
    ten!: string;
    tenEn!: string | undefined;
    alpha2Code!: string | undefined;
    alpha3Code!: string | undefined;
    id!: string | undefined;

    constructor(data?: IQuocTichDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.tenEn = _data["tenEn"];
            this.alpha2Code = _data["alpha2Code"];
            this.alpha3Code = _data["alpha3Code"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): QuocTichDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuocTichDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["tenEn"] = this.tenEn;
        data["alpha2Code"] = this.alpha2Code;
        data["alpha3Code"] = this.alpha3Code;
        data["id"] = this.id;
        return data;
    }
}

export interface IQuocTichDto {
    ten: string;
    tenEn: string | undefined;
    alpha2Code: string | undefined;
    alpha3Code: string | undefined;
    id: string | undefined;
}

export class QuocTichDtoPagedResultDto implements IQuocTichDtoPagedResultDto {
    totalCount!: number;
    items!: QuocTichDto[] | undefined;

    constructor(data?: IQuocTichDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(QuocTichDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuocTichDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuocTichDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuocTichDtoPagedResultDto {
    totalCount: number;
    items: QuocTichDto[] | undefined;
}

export class ExportQuocTichRequest implements IExportQuocTichRequest {
    filterInput!: PagingQuocTichRequest;

    constructor(data?: IExportQuocTichRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filterInput = _data["filterInput"] ? PagingQuocTichRequest.fromJS(_data["filterInput"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExportQuocTichRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExportQuocTichRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterInput"] = this.filterInput ? this.filterInput.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExportQuocTichRequest {
    filterInput: PagingQuocTichRequest;
}

export class CheckValidImportExcelQuocTichDto implements ICheckValidImportExcelQuocTichDto {
    stt!: number;
    id!: string | undefined;
    ten!: string | undefined;
    tenEn!: string | undefined;
    alpha2Code!: string | undefined;
    alpha3Code!: string | undefined;
    isValid!: boolean;
    listError!: string[] | undefined;

    constructor(data?: ICheckValidImportExcelQuocTichDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stt = _data["stt"];
            this.id = _data["id"];
            this.ten = _data["ten"];
            this.tenEn = _data["tenEn"];
            this.alpha2Code = _data["alpha2Code"];
            this.alpha3Code = _data["alpha3Code"];
            this.isValid = _data["isValid"];
            if (Array.isArray(_data["listError"])) {
                this.listError = [] as any;
                for (let item of _data["listError"])
                    this.listError!.push(item);
            }
        }
    }

    static fromJS(data: any): CheckValidImportExcelQuocTichDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckValidImportExcelQuocTichDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stt"] = this.stt;
        data["id"] = this.id;
        data["ten"] = this.ten;
        data["tenEn"] = this.tenEn;
        data["alpha2Code"] = this.alpha2Code;
        data["alpha3Code"] = this.alpha3Code;
        data["isValid"] = this.isValid;
        if (Array.isArray(this.listError)) {
            data["listError"] = [];
            for (let item of this.listError)
                data["listError"].push(item);
        }
        return data;
    }
}

export interface ICheckValidImportExcelQuocTichDto {
    stt: number;
    id: string | undefined;
    ten: string | undefined;
    tenEn: string | undefined;
    alpha2Code: string | undefined;
    alpha3Code: string | undefined;
    isValid: boolean;
    listError: string[] | undefined;
}

export class CheckValidImportExcelQuocTichRequest implements ICheckValidImportExcelQuocTichRequest {
    input!: CheckValidImportExcelQuocTichDto[] | undefined;

    constructor(data?: ICheckValidImportExcelQuocTichRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["input"])) {
                this.input = [] as any;
                for (let item of _data["input"])
                    this.input!.push(CheckValidImportExcelQuocTichDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CheckValidImportExcelQuocTichRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CheckValidImportExcelQuocTichRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.input)) {
            data["input"] = [];
            for (let item of this.input)
                data["input"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICheckValidImportExcelQuocTichRequest {
    input: CheckValidImportExcelQuocTichDto[] | undefined;
}

export class UploadExcelQuocGiaRequest implements IUploadExcelQuocGiaRequest {
    listData!: CheckValidImportExcelQuocTichDto[] | undefined;

    constructor(data?: IUploadExcelQuocGiaRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listData"])) {
                this.listData = [] as any;
                for (let item of _data["listData"])
                    this.listData!.push(CheckValidImportExcelQuocTichDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UploadExcelQuocGiaRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UploadExcelQuocGiaRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listData)) {
            data["listData"] = [];
            for (let item of this.listData)
                data["listData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUploadExcelQuocGiaRequest {
    listData: CheckValidImportExcelQuocTichDto[] | undefined;
}

export class QuocTichDtoCommonResultDto implements IQuocTichDtoCommonResultDto {
    dataResult!: QuocTichDto;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: IQuocTichDtoCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"] ? QuocTichDto.fromJS(_data["dataResult"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): QuocTichDtoCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuocTichDtoCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface IQuocTichDtoCommonResultDto {
    dataResult: QuocTichDto;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class TinhDto implements ITinhDto {
    ten!: string;
    ma!: string;
    cap!: string | undefined;
    tenEn!: string | undefined;
    isActive!: boolean;
    isTinhGan!: boolean | undefined;
    readonly tinhGanStr!: string | undefined;
    strTinhGan!: string | undefined;
    phanVung!: number | undefined;
    readonly phanVungStr!: string | undefined;
    id!: string | undefined;

    constructor(data?: ITinhDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.ma = _data["ma"];
            this.cap = _data["cap"];
            this.tenEn = _data["tenEn"];
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : true;
            this.isTinhGan = _data["isTinhGan"];
            (<any>this).tinhGanStr = _data["tinhGanStr"];
            this.strTinhGan = _data["strTinhGan"];
            this.phanVung = _data["phanVung"];
            (<any>this).phanVungStr = _data["phanVungStr"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TinhDto {
        data = typeof data === 'object' ? data : {};
        let result = new TinhDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["ma"] = this.ma;
        data["cap"] = this.cap;
        data["tenEn"] = this.tenEn;
        data["isActive"] = this.isActive;
        data["isTinhGan"] = this.isTinhGan;
        data["tinhGanStr"] = this.tinhGanStr;
        data["strTinhGan"] = this.strTinhGan;
        data["phanVung"] = this.phanVung;
        data["phanVungStr"] = this.phanVungStr;
        data["id"] = this.id;
        return data;
    }
}

export interface ITinhDto {
    ten: string;
    ma: string;
    cap: string | undefined;
    tenEn: string | undefined;
    isActive: boolean;
    isTinhGan: boolean | undefined;
    tinhGanStr: string | undefined;
    strTinhGan: string | undefined;
    phanVung: number | undefined;
    phanVungStr: string | undefined;
    id: string | undefined;
}

export class TinhDtoCommonResultDto implements ITinhDtoCommonResultDto {
    dataResult!: TinhDto;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: ITinhDtoCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"] ? TinhDto.fromJS(_data["dataResult"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): TinhDtoCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TinhDtoCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface ITinhDtoCommonResultDto {
    dataResult: TinhDto;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class CheckValidImportExcelDanhMucTinhDto implements ICheckValidImportExcelDanhMucTinhDto {
    ten!: string | undefined;
    ma!: string | undefined;
    cap!: string | undefined;
    tenEn!: string | undefined;
    isValid!: boolean;
    isActive!: boolean;
    isTinhGan!: boolean | undefined;
    strTinhGan!: string | undefined;
    phanVung!: number | undefined;
    strPhanVung!: string | undefined;
    listError!: string[] | undefined;

    constructor(data?: ICheckValidImportExcelDanhMucTinhDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.ma = _data["ma"];
            this.cap = _data["cap"];
            this.tenEn = _data["tenEn"];
            this.isValid = _data["isValid"];
            this.isActive = _data["isActive"];
            this.isTinhGan = _data["isTinhGan"];
            this.strTinhGan = _data["strTinhGan"];
            this.phanVung = _data["phanVung"];
            this.strPhanVung = _data["strPhanVung"];
            if (Array.isArray(_data["listError"])) {
                this.listError = [] as any;
                for (let item of _data["listError"])
                    this.listError!.push(item);
            }
        }
    }

    static fromJS(data: any): CheckValidImportExcelDanhMucTinhDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckValidImportExcelDanhMucTinhDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["ma"] = this.ma;
        data["cap"] = this.cap;
        data["tenEn"] = this.tenEn;
        data["isValid"] = this.isValid;
        data["isActive"] = this.isActive;
        data["isTinhGan"] = this.isTinhGan;
        data["strTinhGan"] = this.strTinhGan;
        data["phanVung"] = this.phanVung;
        data["strPhanVung"] = this.strPhanVung;
        if (Array.isArray(this.listError)) {
            data["listError"] = [];
            for (let item of this.listError)
                data["listError"].push(item);
        }
        return data;
    }
}

export interface ICheckValidImportExcelDanhMucTinhDto {
    ten: string | undefined;
    ma: string | undefined;
    cap: string | undefined;
    tenEn: string | undefined;
    isValid: boolean;
    isActive: boolean;
    isTinhGan: boolean | undefined;
    strTinhGan: string | undefined;
    phanVung: number | undefined;
    strPhanVung: string | undefined;
    listError: string[] | undefined;
}

export class CheckValidImportExcelDanhMucTinhRequest implements ICheckValidImportExcelDanhMucTinhRequest {
    input!: CheckValidImportExcelDanhMucTinhDto[] | undefined;

    constructor(data?: ICheckValidImportExcelDanhMucTinhRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["input"])) {
                this.input = [] as any;
                for (let item of _data["input"])
                    this.input!.push(CheckValidImportExcelDanhMucTinhDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CheckValidImportExcelDanhMucTinhRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CheckValidImportExcelDanhMucTinhRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.input)) {
            data["input"] = [];
            for (let item of this.input)
                data["input"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICheckValidImportExcelDanhMucTinhRequest {
    input: CheckValidImportExcelDanhMucTinhDto[] | undefined;
}

export class UploadExcelDanhMucTinhRequest implements IUploadExcelDanhMucTinhRequest {
    listData!: CheckValidImportExcelDanhMucTinhDto[] | undefined;

    constructor(data?: IUploadExcelDanhMucTinhRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listData"])) {
                this.listData = [] as any;
                for (let item of _data["listData"])
                    this.listData!.push(CheckValidImportExcelDanhMucTinhDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UploadExcelDanhMucTinhRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UploadExcelDanhMucTinhRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listData)) {
            data["listData"] = [];
            for (let item of this.listData)
                data["listData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUploadExcelDanhMucTinhRequest {
    listData: CheckValidImportExcelDanhMucTinhDto[] | undefined;
}

export class PagingDanhMucTinhRequest implements IPagingDanhMucTinhRequest {
    phanVung!: number | undefined;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingDanhMucTinhRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phanVung = _data["phanVung"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingDanhMucTinhRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingDanhMucTinhRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phanVung"] = this.phanVung;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingDanhMucTinhRequest {
    phanVung: number | undefined;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class ExportDanhMucTinhRequest implements IExportDanhMucTinhRequest {
    filterInput!: PagingDanhMucTinhRequest;

    constructor(data?: IExportDanhMucTinhRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filterInput = _data["filterInput"] ? PagingDanhMucTinhRequest.fromJS(_data["filterInput"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExportDanhMucTinhRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExportDanhMucTinhRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterInput"] = this.filterInput ? this.filterInput.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExportDanhMucTinhRequest {
    filterInput: PagingDanhMucTinhRequest;
}

export class TinhPagedRequestDto implements ITinhPagedRequestDto {
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: ITinhPagedRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): TinhPagedRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new TinhPagedRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface ITinhPagedRequestDto {
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class TinhDtoPagedResultDto implements ITinhDtoPagedResultDto {
    totalCount!: number;
    items!: TinhDto[] | undefined;

    constructor(data?: ITinhDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TinhDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TinhDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TinhDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITinhDtoPagedResultDto {
    totalCount: number;
    items: TinhDto[] | undefined;
}

export class PagingXaRequest implements IPagingXaRequest {
    huyenId!: string | undefined;
    tinhId!: string | undefined;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingXaRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.huyenId = _data["huyenId"];
            this.tinhId = _data["tinhId"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingXaRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingXaRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["huyenId"] = this.huyenId;
        data["tinhId"] = this.tinhId;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingXaRequest {
    huyenId: string | undefined;
    tinhId: string | undefined;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class XaDto implements IXaDto {
    ten!: string;
    cap!: string | undefined;
    huyenId!: string;
    tinhId!: string;
    tenEn!: string | undefined;
    isActive!: boolean;
    tenTinh!: string | undefined;
    tenHuyen!: string | undefined;
    id!: string | undefined;

    constructor(data?: IXaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.cap = _data["cap"];
            this.huyenId = _data["huyenId"];
            this.tinhId = _data["tinhId"];
            this.tenEn = _data["tenEn"];
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : true;
            this.tenTinh = _data["tenTinh"];
            this.tenHuyen = _data["tenHuyen"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): XaDto {
        data = typeof data === 'object' ? data : {};
        let result = new XaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["cap"] = this.cap;
        data["huyenId"] = this.huyenId;
        data["tinhId"] = this.tinhId;
        data["tenEn"] = this.tenEn;
        data["isActive"] = this.isActive;
        data["tenTinh"] = this.tenTinh;
        data["tenHuyen"] = this.tenHuyen;
        data["id"] = this.id;
        return data;
    }
}

export interface IXaDto {
    ten: string;
    cap: string | undefined;
    huyenId: string;
    tinhId: string;
    tenEn: string | undefined;
    isActive: boolean;
    tenTinh: string | undefined;
    tenHuyen: string | undefined;
    id: string | undefined;
}

export class XaDtoPagedResultDto implements IXaDtoPagedResultDto {
    totalCount!: number;
    items!: XaDto[] | undefined;

    constructor(data?: IXaDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(XaDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): XaDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new XaDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IXaDtoPagedResultDto {
    totalCount: number;
    items: XaDto[] | undefined;
}

export class CheckValidImportExcelXaDto implements ICheckValidImportExcelXaDto {
    tinhId!: string | undefined;
    huyenId!: string | undefined;
    id!: string | undefined;
    ten!: string | undefined;
    cap!: string | undefined;
    isActive!: boolean;
    isValid!: boolean;
    listError!: string[] | undefined;

    constructor(data?: ICheckValidImportExcelXaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tinhId = _data["tinhId"];
            this.huyenId = _data["huyenId"];
            this.id = _data["id"];
            this.ten = _data["ten"];
            this.cap = _data["cap"];
            this.isActive = _data["isActive"];
            this.isValid = _data["isValid"];
            if (Array.isArray(_data["listError"])) {
                this.listError = [] as any;
                for (let item of _data["listError"])
                    this.listError!.push(item);
            }
        }
    }

    static fromJS(data: any): CheckValidImportExcelXaDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckValidImportExcelXaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tinhId"] = this.tinhId;
        data["huyenId"] = this.huyenId;
        data["id"] = this.id;
        data["ten"] = this.ten;
        data["cap"] = this.cap;
        data["isActive"] = this.isActive;
        data["isValid"] = this.isValid;
        if (Array.isArray(this.listError)) {
            data["listError"] = [];
            for (let item of this.listError)
                data["listError"].push(item);
        }
        return data;
    }
}

export interface ICheckValidImportExcelXaDto {
    tinhId: string | undefined;
    huyenId: string | undefined;
    id: string | undefined;
    ten: string | undefined;
    cap: string | undefined;
    isActive: boolean;
    isValid: boolean;
    listError: string[] | undefined;
}

export class CheckValidImportExcelXaRequest implements ICheckValidImportExcelXaRequest {
    input!: CheckValidImportExcelXaDto[] | undefined;

    constructor(data?: ICheckValidImportExcelXaRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["input"])) {
                this.input = [] as any;
                for (let item of _data["input"])
                    this.input!.push(CheckValidImportExcelXaDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CheckValidImportExcelXaRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CheckValidImportExcelXaRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.input)) {
            data["input"] = [];
            for (let item of this.input)
                data["input"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICheckValidImportExcelXaRequest {
    input: CheckValidImportExcelXaDto[] | undefined;
}

export class UploadExcelXaRequest implements IUploadExcelXaRequest {
    listData!: CheckValidImportExcelXaDto[] | undefined;

    constructor(data?: IUploadExcelXaRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listData"])) {
                this.listData = [] as any;
                for (let item of _data["listData"])
                    this.listData!.push(CheckValidImportExcelXaDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UploadExcelXaRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UploadExcelXaRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listData)) {
            data["listData"] = [];
            for (let item of this.listData)
                data["listData"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUploadExcelXaRequest {
    listData: CheckValidImportExcelXaDto[] | undefined;
}

export class ExportXaRequest implements IExportXaRequest {
    filterInput!: PagingXaRequest;

    constructor(data?: IExportXaRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filterInput = _data["filterInput"] ? PagingXaRequest.fromJS(_data["filterInput"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExportXaRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExportXaRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterInput"] = this.filterInput ? this.filterInput.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExportXaRequest {
    filterInput: PagingXaRequest;
}

export class XaDtoCommonResultDto implements IXaDtoCommonResultDto {
    dataResult!: XaDto;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: IXaDtoCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"] ? XaDto.fromJS(_data["dataResult"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): XaDtoCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new XaDtoCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface IXaDtoCommonResultDto {
    dataResult: XaDto;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class PagingListHangPhongRequest implements IPagingListHangPhongRequest {
    nhaCungCapId!: number;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingListHangPhongRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCapId = _data["nhaCungCapId"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingListHangPhongRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingListHangPhongRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCapId"] = this.nhaCungCapId;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingListHangPhongRequest {
    nhaCungCapId: number;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class DichVuGiaPhongDto implements IDichVuGiaPhongDto {
    nhaCungCapKhachSanId!: number;
    tenNhaCungCap!: string | undefined;
    tenPhong!: string | undefined;
    hangPhongId!: number;
    tenHangPHong!: string | undefined;
    loaiPhongCode!: string | undefined;
    loaiTienTeCode!: string | undefined;
    giaFOTNettNgayThuong!: number | undefined;
    giaFOTBanNgayThuong!: number | undefined;
    giaFOTNettNgayLe!: number | undefined;
    giaFOTBanNgayLe!: number | undefined;
    ngayApDungTu!: DateTime | undefined;
    ngayApDungDen!: DateTime | undefined;
    ghiChu!: string | undefined;
    isHasThueVAT!: boolean;
    id!: number;

    constructor(data?: IDichVuGiaPhongDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCapKhachSanId = _data["nhaCungCapKhachSanId"];
            this.tenNhaCungCap = _data["tenNhaCungCap"];
            this.tenPhong = _data["tenPhong"];
            this.hangPhongId = _data["hangPhongId"];
            this.tenHangPHong = _data["tenHangPHong"];
            this.loaiPhongCode = _data["loaiPhongCode"];
            this.loaiTienTeCode = _data["loaiTienTeCode"];
            this.giaFOTNettNgayThuong = _data["giaFOTNettNgayThuong"];
            this.giaFOTBanNgayThuong = _data["giaFOTBanNgayThuong"];
            this.giaFOTNettNgayLe = _data["giaFOTNettNgayLe"];
            this.giaFOTBanNgayLe = _data["giaFOTBanNgayLe"];
            this.ngayApDungTu = _data["ngayApDungTu"] ? DateTime.fromISO(_data["ngayApDungTu"].toString()) : <any>undefined;
            this.ngayApDungDen = _data["ngayApDungDen"] ? DateTime.fromISO(_data["ngayApDungDen"].toString()) : <any>undefined;
            this.ghiChu = _data["ghiChu"];
            this.isHasThueVAT = _data["isHasThueVAT"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DichVuGiaPhongDto {
        data = typeof data === 'object' ? data : {};
        let result = new DichVuGiaPhongDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCapKhachSanId"] = this.nhaCungCapKhachSanId;
        data["tenNhaCungCap"] = this.tenNhaCungCap;
        data["tenPhong"] = this.tenPhong;
        data["hangPhongId"] = this.hangPhongId;
        data["tenHangPHong"] = this.tenHangPHong;
        data["loaiPhongCode"] = this.loaiPhongCode;
        data["loaiTienTeCode"] = this.loaiTienTeCode;
        data["giaFOTNettNgayThuong"] = this.giaFOTNettNgayThuong;
        data["giaFOTBanNgayThuong"] = this.giaFOTBanNgayThuong;
        data["giaFOTNettNgayLe"] = this.giaFOTNettNgayLe;
        data["giaFOTBanNgayLe"] = this.giaFOTBanNgayLe;
        data["ngayApDungTu"] = this.ngayApDungTu ? this.ngayApDungTu.toString() : <any>undefined;
        data["ngayApDungDen"] = this.ngayApDungDen ? this.ngayApDungDen.toString() : <any>undefined;
        data["ghiChu"] = this.ghiChu;
        data["isHasThueVAT"] = this.isHasThueVAT;
        data["id"] = this.id;
        return data;
    }
}

export interface IDichVuGiaPhongDto {
    nhaCungCapKhachSanId: number;
    tenNhaCungCap: string | undefined;
    tenPhong: string | undefined;
    hangPhongId: number;
    tenHangPHong: string | undefined;
    loaiPhongCode: string | undefined;
    loaiTienTeCode: string | undefined;
    giaFOTNettNgayThuong: number | undefined;
    giaFOTBanNgayThuong: number | undefined;
    giaFOTNettNgayLe: number | undefined;
    giaFOTBanNgayLe: number | undefined;
    ngayApDungTu: DateTime | undefined;
    ngayApDungDen: DateTime | undefined;
    ghiChu: string | undefined;
    isHasThueVAT: boolean;
    id: number;
}

export class DichVuHangPhongDto implements IDichVuHangPhongDto {
    loaiPhongCode!: string | undefined;
    tenHangPhong!: string | undefined;
    nhaCungCapId!: number;
    moTa!: string | undefined;
    soLuongPhong!: number | undefined;
    soKhachToiDa!: number | undefined;
    kichThuocPhong!: number | undefined;
    slPhongFOC!: number | undefined;
    tienIchPhong!: string | undefined;
    jsonTaiLieu!: string | undefined;
    listDichVuGiaPhong!: DichVuGiaPhongDto[] | undefined;
    id!: number;

    constructor(data?: IDichVuHangPhongDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loaiPhongCode = _data["loaiPhongCode"];
            this.tenHangPhong = _data["tenHangPhong"];
            this.nhaCungCapId = _data["nhaCungCapId"];
            this.moTa = _data["moTa"];
            this.soLuongPhong = _data["soLuongPhong"];
            this.soKhachToiDa = _data["soKhachToiDa"];
            this.kichThuocPhong = _data["kichThuocPhong"];
            this.slPhongFOC = _data["slPhongFOC"];
            this.tienIchPhong = _data["tienIchPhong"];
            this.jsonTaiLieu = _data["jsonTaiLieu"];
            if (Array.isArray(_data["listDichVuGiaPhong"])) {
                this.listDichVuGiaPhong = [] as any;
                for (let item of _data["listDichVuGiaPhong"])
                    this.listDichVuGiaPhong!.push(DichVuGiaPhongDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DichVuHangPhongDto {
        data = typeof data === 'object' ? data : {};
        let result = new DichVuHangPhongDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loaiPhongCode"] = this.loaiPhongCode;
        data["tenHangPhong"] = this.tenHangPhong;
        data["nhaCungCapId"] = this.nhaCungCapId;
        data["moTa"] = this.moTa;
        data["soLuongPhong"] = this.soLuongPhong;
        data["soKhachToiDa"] = this.soKhachToiDa;
        data["kichThuocPhong"] = this.kichThuocPhong;
        data["slPhongFOC"] = this.slPhongFOC;
        data["tienIchPhong"] = this.tienIchPhong;
        data["jsonTaiLieu"] = this.jsonTaiLieu;
        if (Array.isArray(this.listDichVuGiaPhong)) {
            data["listDichVuGiaPhong"] = [];
            for (let item of this.listDichVuGiaPhong)
                data["listDichVuGiaPhong"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IDichVuHangPhongDto {
    loaiPhongCode: string | undefined;
    tenHangPhong: string | undefined;
    nhaCungCapId: number;
    moTa: string | undefined;
    soLuongPhong: number | undefined;
    soKhachToiDa: number | undefined;
    kichThuocPhong: number | undefined;
    slPhongFOC: number | undefined;
    tienIchPhong: string | undefined;
    jsonTaiLieu: string | undefined;
    listDichVuGiaPhong: DichVuGiaPhongDto[] | undefined;
    id: number;
}

export class DichVuHangPhongDtoPagedResultDto implements IDichVuHangPhongDtoPagedResultDto {
    totalCount!: number;
    items!: DichVuHangPhongDto[] | undefined;

    constructor(data?: IDichVuHangPhongDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DichVuHangPhongDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DichVuHangPhongDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DichVuHangPhongDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDichVuHangPhongDtoPagedResultDto {
    totalCount: number;
    items: DichVuHangPhongDto[] | undefined;
}

export class CreateOrUpdateHangPhongRequest implements ICreateOrUpdateHangPhongRequest {
    loaiPhongCode!: string | undefined;
    nhaCungCapId!: number;
    tenHangPhong!: string | undefined;
    moTa!: string | undefined;
    soLuongPhong!: number | undefined;
    soKhachToiDa!: number | undefined;
    kichThuocPhong!: number | undefined;
    slPhongFOC!: number | undefined;
    tienIchPhong!: string | undefined;
    jsonTaiLieu!: string | undefined;
    id!: number;

    constructor(data?: ICreateOrUpdateHangPhongRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loaiPhongCode = _data["loaiPhongCode"];
            this.nhaCungCapId = _data["nhaCungCapId"];
            this.tenHangPhong = _data["tenHangPhong"];
            this.moTa = _data["moTa"];
            this.soLuongPhong = _data["soLuongPhong"];
            this.soKhachToiDa = _data["soKhachToiDa"];
            this.kichThuocPhong = _data["kichThuocPhong"];
            this.slPhongFOC = _data["slPhongFOC"];
            this.tienIchPhong = _data["tienIchPhong"];
            this.jsonTaiLieu = _data["jsonTaiLieu"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateHangPhongRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateHangPhongRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loaiPhongCode"] = this.loaiPhongCode;
        data["nhaCungCapId"] = this.nhaCungCapId;
        data["tenHangPhong"] = this.tenHangPhong;
        data["moTa"] = this.moTa;
        data["soLuongPhong"] = this.soLuongPhong;
        data["soKhachToiDa"] = this.soKhachToiDa;
        data["kichThuocPhong"] = this.kichThuocPhong;
        data["slPhongFOC"] = this.slPhongFOC;
        data["tienIchPhong"] = this.tienIchPhong;
        data["jsonTaiLieu"] = this.jsonTaiLieu;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrUpdateHangPhongRequest {
    loaiPhongCode: string | undefined;
    nhaCungCapId: number;
    tenHangPhong: string | undefined;
    moTa: string | undefined;
    soLuongPhong: number | undefined;
    soKhachToiDa: number | undefined;
    kichThuocPhong: number | undefined;
    slPhongFOC: number | undefined;
    tienIchPhong: string | undefined;
    jsonTaiLieu: string | undefined;
    id: number;
}

export class PagingListGiaPhongRequest implements IPagingListGiaPhongRequest {
    nhaCungCapKhachSanId!: number;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingListGiaPhongRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCapKhachSanId = _data["nhaCungCapKhachSanId"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingListGiaPhongRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingListGiaPhongRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCapKhachSanId"] = this.nhaCungCapKhachSanId;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingListGiaPhongRequest {
    nhaCungCapKhachSanId: number;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class DichVuGiaPhongDtoPagedResultDto implements IDichVuGiaPhongDtoPagedResultDto {
    totalCount!: number;
    items!: DichVuGiaPhongDto[] | undefined;

    constructor(data?: IDichVuGiaPhongDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DichVuGiaPhongDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DichVuGiaPhongDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DichVuGiaPhongDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDichVuGiaPhongDtoPagedResultDto {
    totalCount: number;
    items: DichVuGiaPhongDto[] | undefined;
}

export class CreateOrUpdateDichVuGiaPhongRequest implements ICreateOrUpdateDichVuGiaPhongRequest {
    nhaCungCapKhachSanId!: number;
    hangPhongId!: number;
    tenPhong!: string | undefined;
    loaiPhongCode!: string | undefined;
    loaiTienTeCode!: string | undefined;
    giaFOTNettNgayThuong!: number | undefined;
    giaFOTBanNgayThuong!: number | undefined;
    giaFOTNettNgayLe!: number | undefined;
    giaFOTBanNgayLe!: number | undefined;
    ngayApDungTu!: DateTime | undefined;
    ngayApDungDen!: DateTime | undefined;
    ghiChu!: string | undefined;
    isHasThueVAT!: boolean;
    id!: number;

    constructor(data?: ICreateOrUpdateDichVuGiaPhongRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCapKhachSanId = _data["nhaCungCapKhachSanId"];
            this.hangPhongId = _data["hangPhongId"];
            this.tenPhong = _data["tenPhong"];
            this.loaiPhongCode = _data["loaiPhongCode"];
            this.loaiTienTeCode = _data["loaiTienTeCode"];
            this.giaFOTNettNgayThuong = _data["giaFOTNettNgayThuong"];
            this.giaFOTBanNgayThuong = _data["giaFOTBanNgayThuong"];
            this.giaFOTNettNgayLe = _data["giaFOTNettNgayLe"];
            this.giaFOTBanNgayLe = _data["giaFOTBanNgayLe"];
            this.ngayApDungTu = _data["ngayApDungTu"] ? DateTime.fromISO(_data["ngayApDungTu"].toString()) : <any>undefined;
            this.ngayApDungDen = _data["ngayApDungDen"] ? DateTime.fromISO(_data["ngayApDungDen"].toString()) : <any>undefined;
            this.ghiChu = _data["ghiChu"];
            this.isHasThueVAT = _data["isHasThueVAT"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateDichVuGiaPhongRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateDichVuGiaPhongRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCapKhachSanId"] = this.nhaCungCapKhachSanId;
        data["hangPhongId"] = this.hangPhongId;
        data["tenPhong"] = this.tenPhong;
        data["loaiPhongCode"] = this.loaiPhongCode;
        data["loaiTienTeCode"] = this.loaiTienTeCode;
        data["giaFOTNettNgayThuong"] = this.giaFOTNettNgayThuong;
        data["giaFOTBanNgayThuong"] = this.giaFOTBanNgayThuong;
        data["giaFOTNettNgayLe"] = this.giaFOTNettNgayLe;
        data["giaFOTBanNgayLe"] = this.giaFOTBanNgayLe;
        data["ngayApDungTu"] = this.ngayApDungTu ? this.ngayApDungTu.toString() : <any>undefined;
        data["ngayApDungDen"] = this.ngayApDungDen ? this.ngayApDungDen.toString() : <any>undefined;
        data["ghiChu"] = this.ghiChu;
        data["isHasThueVAT"] = this.isHasThueVAT;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrUpdateDichVuGiaPhongRequest {
    nhaCungCapKhachSanId: number;
    hangPhongId: number;
    tenPhong: string | undefined;
    loaiPhongCode: string | undefined;
    loaiTienTeCode: string | undefined;
    giaFOTNettNgayThuong: number | undefined;
    giaFOTBanNgayThuong: number | undefined;
    giaFOTNettNgayLe: number | undefined;
    giaFOTBanNgayLe: number | undefined;
    ngayApDungTu: DateTime | undefined;
    ngayApDungDen: DateTime | undefined;
    ghiChu: string | undefined;
    isHasThueVAT: boolean;
    id: number;
}

export class GetComboboxHangPhongRequest implements IGetComboboxHangPhongRequest {
    nhaCungCapKhachSanId!: number;

    constructor(data?: IGetComboboxHangPhongRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCapKhachSanId = _data["nhaCungCapKhachSanId"];
        }
    }

    static fromJS(data: any): GetComboboxHangPhongRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetComboboxHangPhongRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCapKhachSanId"] = this.nhaCungCapKhachSanId;
        return data;
    }
}

export interface IGetComboboxHangPhongRequest {
    nhaCungCapKhachSanId: number;
}

export class ComboBoxDtoListCommonResultDto implements IComboBoxDtoListCommonResultDto {
    dataResult!: ComboBoxDto[] | undefined;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: IComboBoxDtoListCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dataResult"])) {
                this.dataResult = [] as any;
                for (let item of _data["dataResult"])
                    this.dataResult!.push(ComboBoxDto.fromJS(item));
            }
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): ComboBoxDtoListCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboBoxDtoListCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dataResult)) {
            data["dataResult"] = [];
            for (let item of this.dataResult)
                data["dataResult"].push(item.toJSON());
        }
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface IComboBoxDtoListCommonResultDto {
    dataResult: ComboBoxDto[] | undefined;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class GetHangPhongByIdRequest implements IGetHangPhongByIdRequest {
    id!: number;

    constructor(data?: IGetHangPhongByIdRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetHangPhongByIdRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetHangPhongByIdRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IGetHangPhongByIdRequest {
    id: number;
}

export class DichVuHangPhongDtoCommonResultDto implements IDichVuHangPhongDtoCommonResultDto {
    dataResult!: DichVuHangPhongDto;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: IDichVuHangPhongDtoCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"] ? DichVuHangPhongDto.fromJS(_data["dataResult"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): DichVuHangPhongDtoCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DichVuHangPhongDtoCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface IDichVuHangPhongDtoCommonResultDto {
    dataResult: DichVuHangPhongDto;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class GetGiaPhongByIdRequest implements IGetGiaPhongByIdRequest {
    id!: number;

    constructor(data?: IGetGiaPhongByIdRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetGiaPhongByIdRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetGiaPhongByIdRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IGetGiaPhongByIdRequest {
    id: number;
}

export class DichVuGiaPhongDtoCommonResultDto implements IDichVuGiaPhongDtoCommonResultDto {
    dataResult!: DichVuGiaPhongDto;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: IDichVuGiaPhongDtoCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"] ? DichVuGiaPhongDto.fromJS(_data["dataResult"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): DichVuGiaPhongDtoCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DichVuGiaPhongDtoCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface IDichVuGiaPhongDtoCommonResultDto {
    dataResult: DichVuGiaPhongDto;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class PagingListDichVuVeRequest implements IPagingListDichVuVeRequest {
    nhaCungCapVeId!: number;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingListDichVuVeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCapVeId = _data["nhaCungCapVeId"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingListDichVuVeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingListDichVuVeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCapVeId"] = this.nhaCungCapVeId;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingListDichVuVeRequest {
    nhaCungCapVeId: number;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class DichVuVeDto implements IDichVuVeDto {
    nhaCungCapVeId!: number;
    ma!: string | undefined;
    ten!: string | undefined;
    loaiTienTeCode!: string | undefined;
    loaiTienTeDisplay!: string | undefined;
    giaNett!: number | undefined;
    giaBan!: number | undefined;
    ghiChu!: string | undefined;
    isHasThueVAT!: boolean;
    jsonTaiLieu!: string | undefined;
    tuNgay!: DateTime | undefined;
    denNgay!: DateTime | undefined;
    tinhTrang!: boolean;
    id!: number;

    constructor(data?: IDichVuVeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCapVeId = _data["nhaCungCapVeId"];
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.loaiTienTeCode = _data["loaiTienTeCode"];
            this.loaiTienTeDisplay = _data["loaiTienTeDisplay"];
            this.giaNett = _data["giaNett"];
            this.giaBan = _data["giaBan"];
            this.ghiChu = _data["ghiChu"];
            this.isHasThueVAT = _data["isHasThueVAT"];
            this.jsonTaiLieu = _data["jsonTaiLieu"];
            this.tuNgay = _data["tuNgay"] ? DateTime.fromISO(_data["tuNgay"].toString()) : <any>undefined;
            this.denNgay = _data["denNgay"] ? DateTime.fromISO(_data["denNgay"].toString()) : <any>undefined;
            this.tinhTrang = _data["tinhTrang"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DichVuVeDto {
        data = typeof data === 'object' ? data : {};
        let result = new DichVuVeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCapVeId"] = this.nhaCungCapVeId;
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["loaiTienTeCode"] = this.loaiTienTeCode;
        data["loaiTienTeDisplay"] = this.loaiTienTeDisplay;
        data["giaNett"] = this.giaNett;
        data["giaBan"] = this.giaBan;
        data["ghiChu"] = this.ghiChu;
        data["isHasThueVAT"] = this.isHasThueVAT;
        data["jsonTaiLieu"] = this.jsonTaiLieu;
        data["tuNgay"] = this.tuNgay ? this.tuNgay.toString() : <any>undefined;
        data["denNgay"] = this.denNgay ? this.denNgay.toString() : <any>undefined;
        data["tinhTrang"] = this.tinhTrang;
        data["id"] = this.id;
        return data;
    }
}

export interface IDichVuVeDto {
    nhaCungCapVeId: number;
    ma: string | undefined;
    ten: string | undefined;
    loaiTienTeCode: string | undefined;
    loaiTienTeDisplay: string | undefined;
    giaNett: number | undefined;
    giaBan: number | undefined;
    ghiChu: string | undefined;
    isHasThueVAT: boolean;
    jsonTaiLieu: string | undefined;
    tuNgay: DateTime | undefined;
    denNgay: DateTime | undefined;
    tinhTrang: boolean;
    id: number;
}

export class DichVuVeDtoPagedResultDto implements IDichVuVeDtoPagedResultDto {
    totalCount!: number;
    items!: DichVuVeDto[] | undefined;

    constructor(data?: IDichVuVeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DichVuVeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DichVuVeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DichVuVeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDichVuVeDtoPagedResultDto {
    totalCount: number;
    items: DichVuVeDto[] | undefined;
}

export class CreateOrUpdateDichVuVeRequest implements ICreateOrUpdateDichVuVeRequest {
    nhaCungCapVeId!: number;
    ma!: string | undefined;
    ten!: string | undefined;
    loaiTienTeCode!: string | undefined;
    giaNett!: number | undefined;
    giaBan!: number | undefined;
    ghiChu!: string | undefined;
    isHasThueVAT!: boolean;
    jsonTaiLieu!: string | undefined;
    tuNgay!: DateTime | undefined;
    denNgay!: DateTime | undefined;
    tinhTrang!: boolean;
    id!: number;

    constructor(data?: ICreateOrUpdateDichVuVeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCapVeId = _data["nhaCungCapVeId"];
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.loaiTienTeCode = _data["loaiTienTeCode"];
            this.giaNett = _data["giaNett"];
            this.giaBan = _data["giaBan"];
            this.ghiChu = _data["ghiChu"];
            this.isHasThueVAT = _data["isHasThueVAT"];
            this.jsonTaiLieu = _data["jsonTaiLieu"];
            this.tuNgay = _data["tuNgay"] ? DateTime.fromISO(_data["tuNgay"].toString()) : <any>undefined;
            this.denNgay = _data["denNgay"] ? DateTime.fromISO(_data["denNgay"].toString()) : <any>undefined;
            this.tinhTrang = _data["tinhTrang"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateDichVuVeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateDichVuVeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCapVeId"] = this.nhaCungCapVeId;
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["loaiTienTeCode"] = this.loaiTienTeCode;
        data["giaNett"] = this.giaNett;
        data["giaBan"] = this.giaBan;
        data["ghiChu"] = this.ghiChu;
        data["isHasThueVAT"] = this.isHasThueVAT;
        data["jsonTaiLieu"] = this.jsonTaiLieu;
        data["tuNgay"] = this.tuNgay ? this.tuNgay.toString() : <any>undefined;
        data["denNgay"] = this.denNgay ? this.denNgay.toString() : <any>undefined;
        data["tinhTrang"] = this.tinhTrang;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrUpdateDichVuVeRequest {
    nhaCungCapVeId: number;
    ma: string | undefined;
    ten: string | undefined;
    loaiTienTeCode: string | undefined;
    giaNett: number | undefined;
    giaBan: number | undefined;
    ghiChu: string | undefined;
    isHasThueVAT: boolean;
    jsonTaiLieu: string | undefined;
    tuNgay: DateTime | undefined;
    denNgay: DateTime | undefined;
    tinhTrang: boolean;
    id: number;
}

export class GetDichVuVeByIdRequest implements IGetDichVuVeByIdRequest {
    id!: number;

    constructor(data?: IGetDichVuVeByIdRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetDichVuVeByIdRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetDichVuVeByIdRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IGetDichVuVeByIdRequest {
    id: number;
}

export class DichVuVeDtoCommonResultDto implements IDichVuVeDtoCommonResultDto {
    dataResult!: DichVuVeDto;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: IDichVuVeDtoCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"] ? DichVuVeDto.fromJS(_data["dataResult"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): DichVuVeDtoCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DichVuVeDtoCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface IDichVuVeDtoCommonResultDto {
    dataResult: DichVuVeDto;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class GetNhaCungCapDichVuVeRequest implements IGetNhaCungCapDichVuVeRequest {

    constructor(data?: IGetNhaCungCapDichVuVeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetNhaCungCapDichVuVeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetNhaCungCapDichVuVeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IGetNhaCungCapDichVuVeRequest {
}

export class NhaCungCapDichVuVeDto implements INhaCungCapDichVuVeDto {
    ten!: string | undefined;
    quocGiaId!: number | undefined;
    quocGia!: string | undefined;
    tinhId!: number | undefined;
    tinh!: string | undefined;
    fax!: string | undefined;
    email!: string | undefined;
    isHasThueVAT!: boolean;
    listDichVuVe!: DichVuVeDto[] | undefined;
    id!: number;

    constructor(data?: INhaCungCapDichVuVeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.quocGiaId = _data["quocGiaId"];
            this.quocGia = _data["quocGia"];
            this.tinhId = _data["tinhId"];
            this.tinh = _data["tinh"];
            this.fax = _data["fax"];
            this.email = _data["email"];
            this.isHasThueVAT = _data["isHasThueVAT"];
            if (Array.isArray(_data["listDichVuVe"])) {
                this.listDichVuVe = [] as any;
                for (let item of _data["listDichVuVe"])
                    this.listDichVuVe!.push(DichVuVeDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NhaCungCapDichVuVeDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapDichVuVeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["quocGiaId"] = this.quocGiaId;
        data["quocGia"] = this.quocGia;
        data["tinhId"] = this.tinhId;
        data["tinh"] = this.tinh;
        data["fax"] = this.fax;
        data["email"] = this.email;
        data["isHasThueVAT"] = this.isHasThueVAT;
        if (Array.isArray(this.listDichVuVe)) {
            data["listDichVuVe"] = [];
            for (let item of this.listDichVuVe)
                data["listDichVuVe"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface INhaCungCapDichVuVeDto {
    ten: string | undefined;
    quocGiaId: number | undefined;
    quocGia: string | undefined;
    tinhId: number | undefined;
    tinh: string | undefined;
    fax: string | undefined;
    email: string | undefined;
    isHasThueVAT: boolean;
    listDichVuVe: DichVuVeDto[] | undefined;
    id: number;
}

export class NhaCungCapDichVuVeDtoListCommonResultDto implements INhaCungCapDichVuVeDtoListCommonResultDto {
    dataResult!: NhaCungCapDichVuVeDto[] | undefined;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: INhaCungCapDichVuVeDtoListCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dataResult"])) {
                this.dataResult = [] as any;
                for (let item of _data["dataResult"])
                    this.dataResult!.push(NhaCungCapDichVuVeDto.fromJS(item));
            }
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): NhaCungCapDichVuVeDtoListCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapDichVuVeDtoListCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dataResult)) {
            data["dataResult"] = [];
            for (let item of this.dataResult)
                data["dataResult"].push(item.toJSON());
        }
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface INhaCungCapDichVuVeDtoListCommonResultDto {
    dataResult: NhaCungCapDichVuVeDto[] | undefined;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class PagingListDichVuXeRequest implements IPagingListDichVuXeRequest {
    nhaCungCapXeId!: number;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingListDichVuXeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCapXeId = _data["nhaCungCapXeId"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingListDichVuXeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingListDichVuXeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCapXeId"] = this.nhaCungCapXeId;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingListDichVuXeRequest {
    nhaCungCapXeId: number;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class DichVuXeDto implements IDichVuXeDto {
    nhaCungCapXeId!: number;
    tenNhaCungCap!: string | undefined;
    ma!: string | undefined;
    ten!: string | undefined;
    soKMDuTinh!: number | undefined;
    loaiXeCode!: string | undefined;
    loaiXeDisplay!: string | undefined;
    loaiTienTeCode!: string | undefined;
    loaiTienTeDisplay!: string | undefined;
    soChoCode!: string | undefined;
    soChoDisplay!: string | undefined;
    giaNett!: number | undefined;
    giaBan!: number | undefined;
    ghiChu!: string | undefined;
    isHasThueVAT!: boolean;
    jsonTaiLieu!: string | undefined;
    tuNgay!: DateTime | undefined;
    denNgay!: DateTime | undefined;
    tinhTrang!: boolean;
    id!: number;

    constructor(data?: IDichVuXeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCapXeId = _data["nhaCungCapXeId"];
            this.tenNhaCungCap = _data["tenNhaCungCap"];
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.soKMDuTinh = _data["soKMDuTinh"];
            this.loaiXeCode = _data["loaiXeCode"];
            this.loaiXeDisplay = _data["loaiXeDisplay"];
            this.loaiTienTeCode = _data["loaiTienTeCode"];
            this.loaiTienTeDisplay = _data["loaiTienTeDisplay"];
            this.soChoCode = _data["soChoCode"];
            this.soChoDisplay = _data["soChoDisplay"];
            this.giaNett = _data["giaNett"];
            this.giaBan = _data["giaBan"];
            this.ghiChu = _data["ghiChu"];
            this.isHasThueVAT = _data["isHasThueVAT"];
            this.jsonTaiLieu = _data["jsonTaiLieu"];
            this.tuNgay = _data["tuNgay"] ? DateTime.fromISO(_data["tuNgay"].toString()) : <any>undefined;
            this.denNgay = _data["denNgay"] ? DateTime.fromISO(_data["denNgay"].toString()) : <any>undefined;
            this.tinhTrang = _data["tinhTrang"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DichVuXeDto {
        data = typeof data === 'object' ? data : {};
        let result = new DichVuXeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCapXeId"] = this.nhaCungCapXeId;
        data["tenNhaCungCap"] = this.tenNhaCungCap;
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["soKMDuTinh"] = this.soKMDuTinh;
        data["loaiXeCode"] = this.loaiXeCode;
        data["loaiXeDisplay"] = this.loaiXeDisplay;
        data["loaiTienTeCode"] = this.loaiTienTeCode;
        data["loaiTienTeDisplay"] = this.loaiTienTeDisplay;
        data["soChoCode"] = this.soChoCode;
        data["soChoDisplay"] = this.soChoDisplay;
        data["giaNett"] = this.giaNett;
        data["giaBan"] = this.giaBan;
        data["ghiChu"] = this.ghiChu;
        data["isHasThueVAT"] = this.isHasThueVAT;
        data["jsonTaiLieu"] = this.jsonTaiLieu;
        data["tuNgay"] = this.tuNgay ? this.tuNgay.toString() : <any>undefined;
        data["denNgay"] = this.denNgay ? this.denNgay.toString() : <any>undefined;
        data["tinhTrang"] = this.tinhTrang;
        data["id"] = this.id;
        return data;
    }
}

export interface IDichVuXeDto {
    nhaCungCapXeId: number;
    tenNhaCungCap: string | undefined;
    ma: string | undefined;
    ten: string | undefined;
    soKMDuTinh: number | undefined;
    loaiXeCode: string | undefined;
    loaiXeDisplay: string | undefined;
    loaiTienTeCode: string | undefined;
    loaiTienTeDisplay: string | undefined;
    soChoCode: string | undefined;
    soChoDisplay: string | undefined;
    giaNett: number | undefined;
    giaBan: number | undefined;
    ghiChu: string | undefined;
    isHasThueVAT: boolean;
    jsonTaiLieu: string | undefined;
    tuNgay: DateTime | undefined;
    denNgay: DateTime | undefined;
    tinhTrang: boolean;
    id: number;
}

export class DichVuXeDtoPagedResultDto implements IDichVuXeDtoPagedResultDto {
    totalCount!: number;
    items!: DichVuXeDto[] | undefined;

    constructor(data?: IDichVuXeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DichVuXeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DichVuXeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DichVuXeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDichVuXeDtoPagedResultDto {
    totalCount: number;
    items: DichVuXeDto[] | undefined;
}

export class CreateOrUpdateDichVuXeRequest implements ICreateOrUpdateDichVuXeRequest {
    nhaCungCapXeId!: number;
    ma!: string | undefined;
    ten!: string | undefined;
    soKMDuTinh!: number | undefined;
    loaiXeCode!: string | undefined;
    loaiTienTeCode!: string | undefined;
    soChoCode!: string | undefined;
    giaNett!: number | undefined;
    giaBan!: number | undefined;
    ghiChu!: string | undefined;
    isHasThueVAT!: boolean;
    jsonTaiLieu!: string | undefined;
    tuNgay!: DateTime | undefined;
    denNgay!: DateTime | undefined;
    tinhTrang!: boolean;
    id!: number;

    constructor(data?: ICreateOrUpdateDichVuXeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCapXeId = _data["nhaCungCapXeId"];
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.soKMDuTinh = _data["soKMDuTinh"];
            this.loaiXeCode = _data["loaiXeCode"];
            this.loaiTienTeCode = _data["loaiTienTeCode"];
            this.soChoCode = _data["soChoCode"];
            this.giaNett = _data["giaNett"];
            this.giaBan = _data["giaBan"];
            this.ghiChu = _data["ghiChu"];
            this.isHasThueVAT = _data["isHasThueVAT"];
            this.jsonTaiLieu = _data["jsonTaiLieu"];
            this.tuNgay = _data["tuNgay"] ? DateTime.fromISO(_data["tuNgay"].toString()) : <any>undefined;
            this.denNgay = _data["denNgay"] ? DateTime.fromISO(_data["denNgay"].toString()) : <any>undefined;
            this.tinhTrang = _data["tinhTrang"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateDichVuXeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateDichVuXeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCapXeId"] = this.nhaCungCapXeId;
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["soKMDuTinh"] = this.soKMDuTinh;
        data["loaiXeCode"] = this.loaiXeCode;
        data["loaiTienTeCode"] = this.loaiTienTeCode;
        data["soChoCode"] = this.soChoCode;
        data["giaNett"] = this.giaNett;
        data["giaBan"] = this.giaBan;
        data["ghiChu"] = this.ghiChu;
        data["isHasThueVAT"] = this.isHasThueVAT;
        data["jsonTaiLieu"] = this.jsonTaiLieu;
        data["tuNgay"] = this.tuNgay ? this.tuNgay.toString() : <any>undefined;
        data["denNgay"] = this.denNgay ? this.denNgay.toString() : <any>undefined;
        data["tinhTrang"] = this.tinhTrang;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrUpdateDichVuXeRequest {
    nhaCungCapXeId: number;
    ma: string | undefined;
    ten: string | undefined;
    soKMDuTinh: number | undefined;
    loaiXeCode: string | undefined;
    loaiTienTeCode: string | undefined;
    soChoCode: string | undefined;
    giaNett: number | undefined;
    giaBan: number | undefined;
    ghiChu: string | undefined;
    isHasThueVAT: boolean;
    jsonTaiLieu: string | undefined;
    tuNgay: DateTime | undefined;
    denNgay: DateTime | undefined;
    tinhTrang: boolean;
    id: number;
}

export class GetDichVuXeByIdRequest implements IGetDichVuXeByIdRequest {
    id!: number;

    constructor(data?: IGetDichVuXeByIdRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetDichVuXeByIdRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetDichVuXeByIdRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IGetDichVuXeByIdRequest {
    id: number;
}

export class DichVuXeDtoCommonResultDto implements IDichVuXeDtoCommonResultDto {
    dataResult!: DichVuXeDto;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: IDichVuXeDtoCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"] ? DichVuXeDto.fromJS(_data["dataResult"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): DichVuXeDtoCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DichVuXeDtoCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface IDichVuXeDtoCommonResultDto {
    dataResult: DichVuXeDto;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class GetNhaCungCapDichVuXeRequest implements IGetNhaCungCapDichVuXeRequest {

    constructor(data?: IGetNhaCungCapDichVuXeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetNhaCungCapDichVuXeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetNhaCungCapDichVuXeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IGetNhaCungCapDichVuXeRequest {
}

export class NhaCungCapDichVuXeDto implements INhaCungCapDichVuXeDto {
    ten!: string | undefined;
    quocGiaId!: number | undefined;
    quocGia!: string | undefined;
    tinhId!: number | undefined;
    tinh!: string | undefined;
    fax!: string | undefined;
    email!: string | undefined;
    isHasThueVAT!: boolean;
    listDichVuXe!: DichVuXeDto[] | undefined;
    id!: number;

    constructor(data?: INhaCungCapDichVuXeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.quocGiaId = _data["quocGiaId"];
            this.quocGia = _data["quocGia"];
            this.tinhId = _data["tinhId"];
            this.tinh = _data["tinh"];
            this.fax = _data["fax"];
            this.email = _data["email"];
            this.isHasThueVAT = _data["isHasThueVAT"];
            if (Array.isArray(_data["listDichVuXe"])) {
                this.listDichVuXe = [] as any;
                for (let item of _data["listDichVuXe"])
                    this.listDichVuXe!.push(DichVuXeDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NhaCungCapDichVuXeDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapDichVuXeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["quocGiaId"] = this.quocGiaId;
        data["quocGia"] = this.quocGia;
        data["tinhId"] = this.tinhId;
        data["tinh"] = this.tinh;
        data["fax"] = this.fax;
        data["email"] = this.email;
        data["isHasThueVAT"] = this.isHasThueVAT;
        if (Array.isArray(this.listDichVuXe)) {
            data["listDichVuXe"] = [];
            for (let item of this.listDichVuXe)
                data["listDichVuXe"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface INhaCungCapDichVuXeDto {
    ten: string | undefined;
    quocGiaId: number | undefined;
    quocGia: string | undefined;
    tinhId: number | undefined;
    tinh: string | undefined;
    fax: string | undefined;
    email: string | undefined;
    isHasThueVAT: boolean;
    listDichVuXe: DichVuXeDto[] | undefined;
    id: number;
}

export class NhaCungCapDichVuXeDtoListCommonResultDto implements INhaCungCapDichVuXeDtoListCommonResultDto {
    dataResult!: NhaCungCapDichVuXeDto[] | undefined;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: INhaCungCapDichVuXeDtoListCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dataResult"])) {
                this.dataResult = [] as any;
                for (let item of _data["dataResult"])
                    this.dataResult!.push(NhaCungCapDichVuXeDto.fromJS(item));
            }
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): NhaCungCapDichVuXeDtoListCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapDichVuXeDtoListCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dataResult)) {
            data["dataResult"] = [];
            for (let item of this.dataResult)
                data["dataResult"].push(item.toJSON());
        }
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface INhaCungCapDichVuXeDtoListCommonResultDto {
    dataResult: NhaCungCapDichVuXeDto[] | undefined;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class PagingListHopDongNCCRequest implements IPagingListHopDongNCCRequest {
    nhaCungCapId!: number;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingListHopDongNCCRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCapId = _data["nhaCungCapId"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingListHopDongNCCRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingListHopDongNCCRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCapId"] = this.nhaCungCapId;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingListHopDongNCCRequest {
    nhaCungCapId: number;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class HopDongNCCDto implements IHopDongNCCDto {
    nhaCungCapId!: number;
    ma!: string | undefined;
    loaiHopDongCode!: string | undefined;
    loaiHopDongDisplay!: string | undefined;
    ngayHieuLuc!: DateTime;
    ngayHetHan!: DateTime;
    ngayKy!: DateTime;
    nguoiLapHopDong!: string | undefined;
    tinhTrang!: number;
    moTa!: string | undefined;
    id!: number;

    constructor(data?: IHopDongNCCDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCapId = _data["nhaCungCapId"];
            this.ma = _data["ma"];
            this.loaiHopDongCode = _data["loaiHopDongCode"];
            this.loaiHopDongDisplay = _data["loaiHopDongDisplay"];
            this.ngayHieuLuc = _data["ngayHieuLuc"] ? DateTime.fromISO(_data["ngayHieuLuc"].toString()) : <any>undefined;
            this.ngayHetHan = _data["ngayHetHan"] ? DateTime.fromISO(_data["ngayHetHan"].toString()) : <any>undefined;
            this.ngayKy = _data["ngayKy"] ? DateTime.fromISO(_data["ngayKy"].toString()) : <any>undefined;
            this.nguoiLapHopDong = _data["nguoiLapHopDong"];
            this.tinhTrang = _data["tinhTrang"];
            this.moTa = _data["moTa"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): HopDongNCCDto {
        data = typeof data === 'object' ? data : {};
        let result = new HopDongNCCDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCapId"] = this.nhaCungCapId;
        data["ma"] = this.ma;
        data["loaiHopDongCode"] = this.loaiHopDongCode;
        data["loaiHopDongDisplay"] = this.loaiHopDongDisplay;
        data["ngayHieuLuc"] = this.ngayHieuLuc ? this.ngayHieuLuc.toString() : <any>undefined;
        data["ngayHetHan"] = this.ngayHetHan ? this.ngayHetHan.toString() : <any>undefined;
        data["ngayKy"] = this.ngayKy ? this.ngayKy.toString() : <any>undefined;
        data["nguoiLapHopDong"] = this.nguoiLapHopDong;
        data["tinhTrang"] = this.tinhTrang;
        data["moTa"] = this.moTa;
        data["id"] = this.id;
        return data;
    }
}

export interface IHopDongNCCDto {
    nhaCungCapId: number;
    ma: string | undefined;
    loaiHopDongCode: string | undefined;
    loaiHopDongDisplay: string | undefined;
    ngayHieuLuc: DateTime;
    ngayHetHan: DateTime;
    ngayKy: DateTime;
    nguoiLapHopDong: string | undefined;
    tinhTrang: number;
    moTa: string | undefined;
    id: number;
}

export class HopDongNCCDtoPagedResultDto implements IHopDongNCCDtoPagedResultDto {
    totalCount!: number;
    items!: HopDongNCCDto[] | undefined;

    constructor(data?: IHopDongNCCDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HopDongNCCDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HopDongNCCDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HopDongNCCDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHopDongNCCDtoPagedResultDto {
    totalCount: number;
    items: HopDongNCCDto[] | undefined;
}

export class CreateOrUpdateHopDongNCCRequest implements ICreateOrUpdateHopDongNCCRequest {
    nhaCungCapId!: number;
    ma!: string | undefined;
    loaiHopDongCode!: string | undefined;
    ngayHieuLuc!: DateTime;
    ngayHetHan!: DateTime;
    ngayKy!: DateTime;
    nguoiLapHopDong!: string | undefined;
    tinhTrang!: number;
    moTa!: string | undefined;
    id!: number;

    constructor(data?: ICreateOrUpdateHopDongNCCRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCapId = _data["nhaCungCapId"];
            this.ma = _data["ma"];
            this.loaiHopDongCode = _data["loaiHopDongCode"];
            this.ngayHieuLuc = _data["ngayHieuLuc"] ? DateTime.fromISO(_data["ngayHieuLuc"].toString()) : <any>undefined;
            this.ngayHetHan = _data["ngayHetHan"] ? DateTime.fromISO(_data["ngayHetHan"].toString()) : <any>undefined;
            this.ngayKy = _data["ngayKy"] ? DateTime.fromISO(_data["ngayKy"].toString()) : <any>undefined;
            this.nguoiLapHopDong = _data["nguoiLapHopDong"];
            this.tinhTrang = _data["tinhTrang"];
            this.moTa = _data["moTa"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateHopDongNCCRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateHopDongNCCRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCapId"] = this.nhaCungCapId;
        data["ma"] = this.ma;
        data["loaiHopDongCode"] = this.loaiHopDongCode;
        data["ngayHieuLuc"] = this.ngayHieuLuc ? this.ngayHieuLuc.toString() : <any>undefined;
        data["ngayHetHan"] = this.ngayHetHan ? this.ngayHetHan.toString() : <any>undefined;
        data["ngayKy"] = this.ngayKy ? this.ngayKy.toString() : <any>undefined;
        data["nguoiLapHopDong"] = this.nguoiLapHopDong;
        data["tinhTrang"] = this.tinhTrang;
        data["moTa"] = this.moTa;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrUpdateHopDongNCCRequest {
    nhaCungCapId: number;
    ma: string | undefined;
    loaiHopDongCode: string | undefined;
    ngayHieuLuc: DateTime;
    ngayHetHan: DateTime;
    ngayKy: DateTime;
    nguoiLapHopDong: string | undefined;
    tinhTrang: number;
    moTa: string | undefined;
    id: number;
}

export class PagingListNguoiLienHeRequest implements IPagingListNguoiLienHeRequest {
    nhaCungCapId!: number;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingListNguoiLienHeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nhaCungCapId = _data["nhaCungCapId"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingListNguoiLienHeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingListNguoiLienHeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nhaCungCapId"] = this.nhaCungCapId;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingListNguoiLienHeRequest {
    nhaCungCapId: number;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class NguoiLienHeNCCDto implements INguoiLienHeNCCDto {
    hoVaTen!: string | undefined;
    phongBan!: string | undefined;
    chucVu!: string | undefined;
    dienThoai!: string | undefined;
    email!: string | undefined;
    nhaCungCapId!: number;
    nhaCungCapCode!: string | undefined;
    id!: number;

    constructor(data?: INguoiLienHeNCCDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hoVaTen = _data["hoVaTen"];
            this.phongBan = _data["phongBan"];
            this.chucVu = _data["chucVu"];
            this.dienThoai = _data["dienThoai"];
            this.email = _data["email"];
            this.nhaCungCapId = _data["nhaCungCapId"];
            this.nhaCungCapCode = _data["nhaCungCapCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NguoiLienHeNCCDto {
        data = typeof data === 'object' ? data : {};
        let result = new NguoiLienHeNCCDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hoVaTen"] = this.hoVaTen;
        data["phongBan"] = this.phongBan;
        data["chucVu"] = this.chucVu;
        data["dienThoai"] = this.dienThoai;
        data["email"] = this.email;
        data["nhaCungCapId"] = this.nhaCungCapId;
        data["nhaCungCapCode"] = this.nhaCungCapCode;
        data["id"] = this.id;
        return data;
    }
}

export interface INguoiLienHeNCCDto {
    hoVaTen: string | undefined;
    phongBan: string | undefined;
    chucVu: string | undefined;
    dienThoai: string | undefined;
    email: string | undefined;
    nhaCungCapId: number;
    nhaCungCapCode: string | undefined;
    id: number;
}

export class NguoiLienHeNCCDtoPagedResultDto implements INguoiLienHeNCCDtoPagedResultDto {
    totalCount!: number;
    items!: NguoiLienHeNCCDto[] | undefined;

    constructor(data?: INguoiLienHeNCCDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NguoiLienHeNCCDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NguoiLienHeNCCDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NguoiLienHeNCCDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface INguoiLienHeNCCDtoPagedResultDto {
    totalCount: number;
    items: NguoiLienHeNCCDto[] | undefined;
}

export class CreateOrUpdateNguoiLienHeNCCRequest implements ICreateOrUpdateNguoiLienHeNCCRequest {
    hoVaTen!: string | undefined;
    phongBan!: string | undefined;
    chucVu!: string | undefined;
    dienThoai!: string | undefined;
    email!: string | undefined;
    nhaCungCapId!: number;
    nhaCungCapCode!: string | undefined;
    id!: number;

    constructor(data?: ICreateOrUpdateNguoiLienHeNCCRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hoVaTen = _data["hoVaTen"];
            this.phongBan = _data["phongBan"];
            this.chucVu = _data["chucVu"];
            this.dienThoai = _data["dienThoai"];
            this.email = _data["email"];
            this.nhaCungCapId = _data["nhaCungCapId"];
            this.nhaCungCapCode = _data["nhaCungCapCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateNguoiLienHeNCCRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateNguoiLienHeNCCRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hoVaTen"] = this.hoVaTen;
        data["phongBan"] = this.phongBan;
        data["chucVu"] = this.chucVu;
        data["dienThoai"] = this.dienThoai;
        data["email"] = this.email;
        data["nhaCungCapId"] = this.nhaCungCapId;
        data["nhaCungCapCode"] = this.nhaCungCapCode;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrUpdateNguoiLienHeNCCRequest {
    hoVaTen: string | undefined;
    phongBan: string | undefined;
    chucVu: string | undefined;
    dienThoai: string | undefined;
    email: string | undefined;
    nhaCungCapId: number;
    nhaCungCapCode: string | undefined;
    id: number;
}

export class GetNguoiLienByIdRequest implements IGetNguoiLienByIdRequest {
    id!: number;

    constructor(data?: IGetNguoiLienByIdRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetNguoiLienByIdRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetNguoiLienByIdRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IGetNguoiLienByIdRequest {
    id: number;
}

export class NguoiLienHeNCCDtoCommonResultDto implements INguoiLienHeNCCDtoCommonResultDto {
    dataResult!: NguoiLienHeNCCDto;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: INguoiLienHeNCCDtoCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"] ? NguoiLienHeNCCDto.fromJS(_data["dataResult"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): NguoiLienHeNCCDtoCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NguoiLienHeNCCDtoCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface INguoiLienHeNCCDtoCommonResultDto {
    dataResult: NguoiLienHeNCCDto;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class PagingNhaCungCapRequest implements IPagingNhaCungCapRequest {
    trangThai!: boolean | undefined;
    listPhanLoai!: string[] | undefined;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingNhaCungCapRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trangThai = _data["trangThai"];
            if (Array.isArray(_data["listPhanLoai"])) {
                this.listPhanLoai = [] as any;
                for (let item of _data["listPhanLoai"])
                    this.listPhanLoai!.push(item);
            }
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingNhaCungCapRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingNhaCungCapRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trangThai"] = this.trangThai;
        if (Array.isArray(this.listPhanLoai)) {
            data["listPhanLoai"] = [];
            for (let item of this.listPhanLoai)
                data["listPhanLoai"].push(item);
        }
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingNhaCungCapRequest {
    trangThai: boolean | undefined;
    listPhanLoai: string[] | undefined;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class NhaCungCapDto implements INhaCungCapDto {
    ten!: string | undefined;
    tenVietTat!: string | undefined;
    diaChi!: string | undefined;
    tenQuocGia!: string | undefined;
    quocGiaId!: string | undefined;
    tinhId!: string | undefined;
    huyenId!: string | undefined;
    xaId!: string | undefined;
    tenTinh!: string | undefined;
    tenHuyen!: string | undefined;
    tenXa!: string | undefined;
    truSo!: string | undefined;
    daiDien!: string | undefined;
    soDangKyKinhDoanh!: string | undefined;
    logo!: string | undefined;
    tenNguoiDaiDien!: string | undefined;
    emailNguoiDaiDien!: string | undefined;
    dienThoaiNguoiDaiDien!: string | undefined;
    trangThai!: boolean;
    ngayDangKy!: string | undefined;
    phanLoai!: string | undefined;
    phanLoaiStr!: string | undefined;
    id!: number;

    constructor(data?: INhaCungCapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.tenVietTat = _data["tenVietTat"];
            this.diaChi = _data["diaChi"];
            this.tenQuocGia = _data["tenQuocGia"];
            this.quocGiaId = _data["quocGiaId"];
            this.tinhId = _data["tinhId"];
            this.huyenId = _data["huyenId"];
            this.xaId = _data["xaId"];
            this.tenTinh = _data["tenTinh"];
            this.tenHuyen = _data["tenHuyen"];
            this.tenXa = _data["tenXa"];
            this.truSo = _data["truSo"];
            this.daiDien = _data["daiDien"];
            this.soDangKyKinhDoanh = _data["soDangKyKinhDoanh"];
            this.logo = _data["logo"];
            this.tenNguoiDaiDien = _data["tenNguoiDaiDien"];
            this.emailNguoiDaiDien = _data["emailNguoiDaiDien"];
            this.dienThoaiNguoiDaiDien = _data["dienThoaiNguoiDaiDien"];
            this.trangThai = _data["trangThai"];
            this.ngayDangKy = _data["ngayDangKy"];
            this.phanLoai = _data["phanLoai"];
            this.phanLoaiStr = _data["phanLoaiStr"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NhaCungCapDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["tenVietTat"] = this.tenVietTat;
        data["diaChi"] = this.diaChi;
        data["tenQuocGia"] = this.tenQuocGia;
        data["quocGiaId"] = this.quocGiaId;
        data["tinhId"] = this.tinhId;
        data["huyenId"] = this.huyenId;
        data["xaId"] = this.xaId;
        data["tenTinh"] = this.tenTinh;
        data["tenHuyen"] = this.tenHuyen;
        data["tenXa"] = this.tenXa;
        data["truSo"] = this.truSo;
        data["daiDien"] = this.daiDien;
        data["soDangKyKinhDoanh"] = this.soDangKyKinhDoanh;
        data["logo"] = this.logo;
        data["tenNguoiDaiDien"] = this.tenNguoiDaiDien;
        data["emailNguoiDaiDien"] = this.emailNguoiDaiDien;
        data["dienThoaiNguoiDaiDien"] = this.dienThoaiNguoiDaiDien;
        data["trangThai"] = this.trangThai;
        data["ngayDangKy"] = this.ngayDangKy;
        data["phanLoai"] = this.phanLoai;
        data["phanLoaiStr"] = this.phanLoaiStr;
        data["id"] = this.id;
        return data;
    }
}

export interface INhaCungCapDto {
    ten: string | undefined;
    tenVietTat: string | undefined;
    diaChi: string | undefined;
    tenQuocGia: string | undefined;
    quocGiaId: string | undefined;
    tinhId: string | undefined;
    huyenId: string | undefined;
    xaId: string | undefined;
    tenTinh: string | undefined;
    tenHuyen: string | undefined;
    tenXa: string | undefined;
    truSo: string | undefined;
    daiDien: string | undefined;
    soDangKyKinhDoanh: string | undefined;
    logo: string | undefined;
    tenNguoiDaiDien: string | undefined;
    emailNguoiDaiDien: string | undefined;
    dienThoaiNguoiDaiDien: string | undefined;
    trangThai: boolean;
    ngayDangKy: string | undefined;
    phanLoai: string | undefined;
    phanLoaiStr: string | undefined;
    id: number;
}

export class NhaCungCapDtoPagedResultDto implements INhaCungCapDtoPagedResultDto {
    totalCount!: number;
    items!: NhaCungCapDto[] | undefined;

    constructor(data?: INhaCungCapDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NhaCungCapDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NhaCungCapDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface INhaCungCapDtoPagedResultDto {
    totalCount: number;
    items: NhaCungCapDto[] | undefined;
}

export class InsertOrUpdateNhaCungCapRequest implements IInsertOrUpdateNhaCungCapRequest {
    ten!: string | undefined;
    tenVietTat!: string | undefined;
    diaChi!: string | undefined;
    tenQuocGia!: string | undefined;
    quocGiaId!: string | undefined;
    tinhId!: string | undefined;
    huyenId!: string | undefined;
    xaId!: string | undefined;
    tenTinh!: string | undefined;
    tenHuyen!: string | undefined;
    tenXa!: string | undefined;
    truSo!: string | undefined;
    daiDien!: string | undefined;
    soDangKyKinhDoanh!: string | undefined;
    logo!: string | undefined;
    tenNguoiDaiDien!: string | undefined;
    emailNguoiDaiDien!: string | undefined;
    dienThoaiNguoiDaiDien!: string | undefined;
    trangThai!: boolean;
    ngayDangKy!: string | undefined;
    phanLoai!: string | undefined;
    phanLoaiStr!: string | undefined;
    id!: number;

    constructor(data?: IInsertOrUpdateNhaCungCapRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ten = _data["ten"];
            this.tenVietTat = _data["tenVietTat"];
            this.diaChi = _data["diaChi"];
            this.tenQuocGia = _data["tenQuocGia"];
            this.quocGiaId = _data["quocGiaId"];
            this.tinhId = _data["tinhId"];
            this.huyenId = _data["huyenId"];
            this.xaId = _data["xaId"];
            this.tenTinh = _data["tenTinh"];
            this.tenHuyen = _data["tenHuyen"];
            this.tenXa = _data["tenXa"];
            this.truSo = _data["truSo"];
            this.daiDien = _data["daiDien"];
            this.soDangKyKinhDoanh = _data["soDangKyKinhDoanh"];
            this.logo = _data["logo"];
            this.tenNguoiDaiDien = _data["tenNguoiDaiDien"];
            this.emailNguoiDaiDien = _data["emailNguoiDaiDien"];
            this.dienThoaiNguoiDaiDien = _data["dienThoaiNguoiDaiDien"];
            this.trangThai = _data["trangThai"];
            this.ngayDangKy = _data["ngayDangKy"];
            this.phanLoai = _data["phanLoai"];
            this.phanLoaiStr = _data["phanLoaiStr"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InsertOrUpdateNhaCungCapRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InsertOrUpdateNhaCungCapRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ten"] = this.ten;
        data["tenVietTat"] = this.tenVietTat;
        data["diaChi"] = this.diaChi;
        data["tenQuocGia"] = this.tenQuocGia;
        data["quocGiaId"] = this.quocGiaId;
        data["tinhId"] = this.tinhId;
        data["huyenId"] = this.huyenId;
        data["xaId"] = this.xaId;
        data["tenTinh"] = this.tenTinh;
        data["tenHuyen"] = this.tenHuyen;
        data["tenXa"] = this.tenXa;
        data["truSo"] = this.truSo;
        data["daiDien"] = this.daiDien;
        data["soDangKyKinhDoanh"] = this.soDangKyKinhDoanh;
        data["logo"] = this.logo;
        data["tenNguoiDaiDien"] = this.tenNguoiDaiDien;
        data["emailNguoiDaiDien"] = this.emailNguoiDaiDien;
        data["dienThoaiNguoiDaiDien"] = this.dienThoaiNguoiDaiDien;
        data["trangThai"] = this.trangThai;
        data["ngayDangKy"] = this.ngayDangKy;
        data["phanLoai"] = this.phanLoai;
        data["phanLoaiStr"] = this.phanLoaiStr;
        data["id"] = this.id;
        return data;
    }
}

export interface IInsertOrUpdateNhaCungCapRequest {
    ten: string | undefined;
    tenVietTat: string | undefined;
    diaChi: string | undefined;
    tenQuocGia: string | undefined;
    quocGiaId: string | undefined;
    tinhId: string | undefined;
    huyenId: string | undefined;
    xaId: string | undefined;
    tenTinh: string | undefined;
    tenHuyen: string | undefined;
    tenXa: string | undefined;
    truSo: string | undefined;
    daiDien: string | undefined;
    soDangKyKinhDoanh: string | undefined;
    logo: string | undefined;
    tenNguoiDaiDien: string | undefined;
    emailNguoiDaiDien: string | undefined;
    dienThoaiNguoiDaiDien: string | undefined;
    trangThai: boolean;
    ngayDangKy: string | undefined;
    phanLoai: string | undefined;
    phanLoaiStr: string | undefined;
    id: number;
}

export class CommResultErrorDto implements ICommResultErrorDto {
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: ICommResultErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): CommResultErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommResultErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface ICommResultErrorDto {
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class ExportExcelNhaCungCapRequest implements IExportExcelNhaCungCapRequest {
    filterInput!: PagingNhaCungCapRequest;

    constructor(data?: IExportExcelNhaCungCapRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filterInput = _data["filterInput"] ? PagingNhaCungCapRequest.fromJS(_data["filterInput"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExportExcelNhaCungCapRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExportExcelNhaCungCapRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterInput"] = this.filterInput ? this.filterInput.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExportExcelNhaCungCapRequest {
    filterInput: PagingNhaCungCapRequest;
}

export class PagingListNhaCungCapKhachSanRequest implements IPagingListNhaCungCapKhachSanRequest {
    soSao!: number | undefined;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingListNhaCungCapKhachSanRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.soSao = _data["soSao"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingListNhaCungCapKhachSanRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingListNhaCungCapKhachSanRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["soSao"] = this.soSao;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingListNhaCungCapKhachSanRequest {
    soSao: number | undefined;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class NhaCungCapKhachSanDto implements INhaCungCapKhachSanDto {
    ma!: string | undefined;
    ten!: string | undefined;
    loaiKhachSanCode!: string | undefined;
    tinhTrang!: boolean;
    quocGiaId!: number | undefined;
    tinhId!: number | undefined;
    diaChi!: string | undefined;
    email!: string | undefined;
    fax!: string | undefined;
    maSoThue!: string | undefined;
    website!: string | undefined;
    moTa!: string | undefined;
    anhDaiDienUrl!: string | undefined;
    taiLieuJson!: string | undefined;
    isHasVAT!: boolean;
    dichVu!: string | undefined;
    soSao!: number;
    ngayHetHanHopDong!: DateTime;
    ngayCuoiTuan!: string | undefined;
    listNguoiLienHeNCC!: NguoiLienHeNCCDto[] | undefined;
    listDichVuHangPhong!: DichVuHangPhongDto[] | undefined;
    id!: number;

    constructor(data?: INhaCungCapKhachSanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.loaiKhachSanCode = _data["loaiKhachSanCode"];
            this.tinhTrang = _data["tinhTrang"];
            this.quocGiaId = _data["quocGiaId"];
            this.tinhId = _data["tinhId"];
            this.diaChi = _data["diaChi"];
            this.email = _data["email"];
            this.fax = _data["fax"];
            this.maSoThue = _data["maSoThue"];
            this.website = _data["website"];
            this.moTa = _data["moTa"];
            this.anhDaiDienUrl = _data["anhDaiDienUrl"];
            this.taiLieuJson = _data["taiLieuJson"];
            this.isHasVAT = _data["isHasVAT"];
            this.dichVu = _data["dichVu"];
            this.soSao = _data["soSao"];
            this.ngayHetHanHopDong = _data["ngayHetHanHopDong"] ? DateTime.fromISO(_data["ngayHetHanHopDong"].toString()) : <any>undefined;
            this.ngayCuoiTuan = _data["ngayCuoiTuan"];
            if (Array.isArray(_data["listNguoiLienHeNCC"])) {
                this.listNguoiLienHeNCC = [] as any;
                for (let item of _data["listNguoiLienHeNCC"])
                    this.listNguoiLienHeNCC!.push(NguoiLienHeNCCDto.fromJS(item));
            }
            if (Array.isArray(_data["listDichVuHangPhong"])) {
                this.listDichVuHangPhong = [] as any;
                for (let item of _data["listDichVuHangPhong"])
                    this.listDichVuHangPhong!.push(DichVuHangPhongDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NhaCungCapKhachSanDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapKhachSanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["loaiKhachSanCode"] = this.loaiKhachSanCode;
        data["tinhTrang"] = this.tinhTrang;
        data["quocGiaId"] = this.quocGiaId;
        data["tinhId"] = this.tinhId;
        data["diaChi"] = this.diaChi;
        data["email"] = this.email;
        data["fax"] = this.fax;
        data["maSoThue"] = this.maSoThue;
        data["website"] = this.website;
        data["moTa"] = this.moTa;
        data["anhDaiDienUrl"] = this.anhDaiDienUrl;
        data["taiLieuJson"] = this.taiLieuJson;
        data["isHasVAT"] = this.isHasVAT;
        data["dichVu"] = this.dichVu;
        data["soSao"] = this.soSao;
        data["ngayHetHanHopDong"] = this.ngayHetHanHopDong ? this.ngayHetHanHopDong.toString() : <any>undefined;
        data["ngayCuoiTuan"] = this.ngayCuoiTuan;
        if (Array.isArray(this.listNguoiLienHeNCC)) {
            data["listNguoiLienHeNCC"] = [];
            for (let item of this.listNguoiLienHeNCC)
                data["listNguoiLienHeNCC"].push(item.toJSON());
        }
        if (Array.isArray(this.listDichVuHangPhong)) {
            data["listDichVuHangPhong"] = [];
            for (let item of this.listDichVuHangPhong)
                data["listDichVuHangPhong"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface INhaCungCapKhachSanDto {
    ma: string | undefined;
    ten: string | undefined;
    loaiKhachSanCode: string | undefined;
    tinhTrang: boolean;
    quocGiaId: number | undefined;
    tinhId: number | undefined;
    diaChi: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    maSoThue: string | undefined;
    website: string | undefined;
    moTa: string | undefined;
    anhDaiDienUrl: string | undefined;
    taiLieuJson: string | undefined;
    isHasVAT: boolean;
    dichVu: string | undefined;
    soSao: number;
    ngayHetHanHopDong: DateTime;
    ngayCuoiTuan: string | undefined;
    listNguoiLienHeNCC: NguoiLienHeNCCDto[] | undefined;
    listDichVuHangPhong: DichVuHangPhongDto[] | undefined;
    id: number;
}

export class NhaCungCapKhachSanDtoPagedResultDto implements INhaCungCapKhachSanDtoPagedResultDto {
    totalCount!: number;
    items!: NhaCungCapKhachSanDto[] | undefined;

    constructor(data?: INhaCungCapKhachSanDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NhaCungCapKhachSanDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NhaCungCapKhachSanDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapKhachSanDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface INhaCungCapKhachSanDtoPagedResultDto {
    totalCount: number;
    items: NhaCungCapKhachSanDto[] | undefined;
}

export class CreateOrUpdateNhaCungCapKhachSanRequest implements ICreateOrUpdateNhaCungCapKhachSanRequest {
    ma!: string | undefined;
    ten!: string | undefined;
    loaiKhachSanCode!: string | undefined;
    tinhTrang!: boolean;
    quocGiaId!: number | undefined;
    tinhId!: number | undefined;
    diaChi!: string | undefined;
    email!: string | undefined;
    fax!: string | undefined;
    website!: string | undefined;
    maSoThue!: string | undefined;
    moTa!: string | undefined;
    anhDaiDienUrl!: string | undefined;
    taiLieuJson!: string | undefined;
    isHasVAT!: boolean;
    dichVu!: string | undefined;
    ngayHetHanHopDong!: DateTime;
    ngayCuoiTuan!: string | undefined;
    soSao!: number;
    id!: number;

    constructor(data?: ICreateOrUpdateNhaCungCapKhachSanRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.loaiKhachSanCode = _data["loaiKhachSanCode"];
            this.tinhTrang = _data["tinhTrang"];
            this.quocGiaId = _data["quocGiaId"];
            this.tinhId = _data["tinhId"];
            this.diaChi = _data["diaChi"];
            this.email = _data["email"];
            this.fax = _data["fax"];
            this.website = _data["website"];
            this.maSoThue = _data["maSoThue"];
            this.moTa = _data["moTa"];
            this.anhDaiDienUrl = _data["anhDaiDienUrl"];
            this.taiLieuJson = _data["taiLieuJson"];
            this.isHasVAT = _data["isHasVAT"];
            this.dichVu = _data["dichVu"];
            this.ngayHetHanHopDong = _data["ngayHetHanHopDong"] ? DateTime.fromISO(_data["ngayHetHanHopDong"].toString()) : <any>undefined;
            this.ngayCuoiTuan = _data["ngayCuoiTuan"];
            this.soSao = _data["soSao"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateNhaCungCapKhachSanRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateNhaCungCapKhachSanRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["loaiKhachSanCode"] = this.loaiKhachSanCode;
        data["tinhTrang"] = this.tinhTrang;
        data["quocGiaId"] = this.quocGiaId;
        data["tinhId"] = this.tinhId;
        data["diaChi"] = this.diaChi;
        data["email"] = this.email;
        data["fax"] = this.fax;
        data["website"] = this.website;
        data["maSoThue"] = this.maSoThue;
        data["moTa"] = this.moTa;
        data["anhDaiDienUrl"] = this.anhDaiDienUrl;
        data["taiLieuJson"] = this.taiLieuJson;
        data["isHasVAT"] = this.isHasVAT;
        data["dichVu"] = this.dichVu;
        data["ngayHetHanHopDong"] = this.ngayHetHanHopDong ? this.ngayHetHanHopDong.toString() : <any>undefined;
        data["ngayCuoiTuan"] = this.ngayCuoiTuan;
        data["soSao"] = this.soSao;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrUpdateNhaCungCapKhachSanRequest {
    ma: string | undefined;
    ten: string | undefined;
    loaiKhachSanCode: string | undefined;
    tinhTrang: boolean;
    quocGiaId: number | undefined;
    tinhId: number | undefined;
    diaChi: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    website: string | undefined;
    maSoThue: string | undefined;
    moTa: string | undefined;
    anhDaiDienUrl: string | undefined;
    taiLieuJson: string | undefined;
    isHasVAT: boolean;
    dichVu: string | undefined;
    ngayHetHanHopDong: DateTime;
    ngayCuoiTuan: string | undefined;
    soSao: number;
    id: number;
}

export class ViewDetailNhaCungCapKhachSanRequest implements IViewDetailNhaCungCapKhachSanRequest {
    id!: number;

    constructor(data?: IViewDetailNhaCungCapKhachSanRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ViewDetailNhaCungCapKhachSanRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ViewDetailNhaCungCapKhachSanRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IViewDetailNhaCungCapKhachSanRequest {
    id: number;
}

export class NhaCungCapKhachSanDtoCommonResultDto implements INhaCungCapKhachSanDtoCommonResultDto {
    dataResult!: NhaCungCapKhachSanDto;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: INhaCungCapKhachSanDtoCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"] ? NhaCungCapKhachSanDto.fromJS(_data["dataResult"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): NhaCungCapKhachSanDtoCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapKhachSanDtoCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface INhaCungCapKhachSanDtoCommonResultDto {
    dataResult: NhaCungCapKhachSanDto;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class PagingListNhaCungCapVeRequest implements IPagingListNhaCungCapVeRequest {
    soSaoDanhGia!: number | undefined;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingListNhaCungCapVeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.soSaoDanhGia = _data["soSaoDanhGia"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingListNhaCungCapVeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingListNhaCungCapVeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["soSaoDanhGia"] = this.soSaoDanhGia;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingListNhaCungCapVeRequest {
    soSaoDanhGia: number | undefined;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class NhaCungCapVeDto implements INhaCungCapVeDto {
    ma!: string | undefined;
    ten!: string | undefined;
    tinhTrang!: boolean;
    quocGiaId!: number | undefined;
    tinhId!: number | undefined;
    diaChi!: string | undefined;
    email!: string | undefined;
    fax!: string | undefined;
    website!: string | undefined;
    moTa!: string | undefined;
    anhDaiDienUrl!: string | undefined;
    taiLieuJson!: string | undefined;
    isHasVAT!: boolean;
    dichVu!: string | undefined;
    soSaoDanhGia!: number | undefined;
    maSoThue!: string | undefined;
    ngayHetHanHopDong!: DateTime;
    id!: number;

    constructor(data?: INhaCungCapVeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.tinhTrang = _data["tinhTrang"];
            this.quocGiaId = _data["quocGiaId"];
            this.tinhId = _data["tinhId"];
            this.diaChi = _data["diaChi"];
            this.email = _data["email"];
            this.fax = _data["fax"];
            this.website = _data["website"];
            this.moTa = _data["moTa"];
            this.anhDaiDienUrl = _data["anhDaiDienUrl"];
            this.taiLieuJson = _data["taiLieuJson"];
            this.isHasVAT = _data["isHasVAT"];
            this.dichVu = _data["dichVu"];
            this.soSaoDanhGia = _data["soSaoDanhGia"];
            this.maSoThue = _data["maSoThue"];
            this.ngayHetHanHopDong = _data["ngayHetHanHopDong"] ? DateTime.fromISO(_data["ngayHetHanHopDong"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NhaCungCapVeDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapVeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["tinhTrang"] = this.tinhTrang;
        data["quocGiaId"] = this.quocGiaId;
        data["tinhId"] = this.tinhId;
        data["diaChi"] = this.diaChi;
        data["email"] = this.email;
        data["fax"] = this.fax;
        data["website"] = this.website;
        data["moTa"] = this.moTa;
        data["anhDaiDienUrl"] = this.anhDaiDienUrl;
        data["taiLieuJson"] = this.taiLieuJson;
        data["isHasVAT"] = this.isHasVAT;
        data["dichVu"] = this.dichVu;
        data["soSaoDanhGia"] = this.soSaoDanhGia;
        data["maSoThue"] = this.maSoThue;
        data["ngayHetHanHopDong"] = this.ngayHetHanHopDong ? this.ngayHetHanHopDong.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface INhaCungCapVeDto {
    ma: string | undefined;
    ten: string | undefined;
    tinhTrang: boolean;
    quocGiaId: number | undefined;
    tinhId: number | undefined;
    diaChi: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    website: string | undefined;
    moTa: string | undefined;
    anhDaiDienUrl: string | undefined;
    taiLieuJson: string | undefined;
    isHasVAT: boolean;
    dichVu: string | undefined;
    soSaoDanhGia: number | undefined;
    maSoThue: string | undefined;
    ngayHetHanHopDong: DateTime;
    id: number;
}

export class NhaCungCapVeDtoPagedResultDto implements INhaCungCapVeDtoPagedResultDto {
    totalCount!: number;
    items!: NhaCungCapVeDto[] | undefined;

    constructor(data?: INhaCungCapVeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NhaCungCapVeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NhaCungCapVeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapVeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface INhaCungCapVeDtoPagedResultDto {
    totalCount: number;
    items: NhaCungCapVeDto[] | undefined;
}

export class CreateOrUpdateNhaCungCapVeRequest implements ICreateOrUpdateNhaCungCapVeRequest {
    ma!: string | undefined;
    ten!: string | undefined;
    tinhTrang!: boolean;
    quocGiaId!: number | undefined;
    tinhId!: number | undefined;
    diaChi!: string | undefined;
    email!: string | undefined;
    fax!: string | undefined;
    website!: string | undefined;
    moTa!: string | undefined;
    anhDaiDienUrl!: string | undefined;
    taiLieuJson!: string | undefined;
    isHasVAT!: boolean;
    dichVu!: string | undefined;
    soSaoDanhGia!: number | undefined;
    maSoThue!: string | undefined;
    ngayHetHanHopDong!: DateTime;
    id!: number;

    constructor(data?: ICreateOrUpdateNhaCungCapVeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.tinhTrang = _data["tinhTrang"];
            this.quocGiaId = _data["quocGiaId"];
            this.tinhId = _data["tinhId"];
            this.diaChi = _data["diaChi"];
            this.email = _data["email"];
            this.fax = _data["fax"];
            this.website = _data["website"];
            this.moTa = _data["moTa"];
            this.anhDaiDienUrl = _data["anhDaiDienUrl"];
            this.taiLieuJson = _data["taiLieuJson"];
            this.isHasVAT = _data["isHasVAT"];
            this.dichVu = _data["dichVu"];
            this.soSaoDanhGia = _data["soSaoDanhGia"];
            this.maSoThue = _data["maSoThue"];
            this.ngayHetHanHopDong = _data["ngayHetHanHopDong"] ? DateTime.fromISO(_data["ngayHetHanHopDong"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateNhaCungCapVeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateNhaCungCapVeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["tinhTrang"] = this.tinhTrang;
        data["quocGiaId"] = this.quocGiaId;
        data["tinhId"] = this.tinhId;
        data["diaChi"] = this.diaChi;
        data["email"] = this.email;
        data["fax"] = this.fax;
        data["website"] = this.website;
        data["moTa"] = this.moTa;
        data["anhDaiDienUrl"] = this.anhDaiDienUrl;
        data["taiLieuJson"] = this.taiLieuJson;
        data["isHasVAT"] = this.isHasVAT;
        data["dichVu"] = this.dichVu;
        data["soSaoDanhGia"] = this.soSaoDanhGia;
        data["maSoThue"] = this.maSoThue;
        data["ngayHetHanHopDong"] = this.ngayHetHanHopDong ? this.ngayHetHanHopDong.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrUpdateNhaCungCapVeRequest {
    ma: string | undefined;
    ten: string | undefined;
    tinhTrang: boolean;
    quocGiaId: number | undefined;
    tinhId: number | undefined;
    diaChi: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    website: string | undefined;
    moTa: string | undefined;
    anhDaiDienUrl: string | undefined;
    taiLieuJson: string | undefined;
    isHasVAT: boolean;
    dichVu: string | undefined;
    soSaoDanhGia: number | undefined;
    maSoThue: string | undefined;
    ngayHetHanHopDong: DateTime;
    id: number;
}

export class GetNCCVeByIdRequest implements IGetNCCVeByIdRequest {
    id!: number;

    constructor(data?: IGetNCCVeByIdRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetNCCVeByIdRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetNCCVeByIdRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IGetNCCVeByIdRequest {
    id: number;
}

export class NhaCungCapVeDtoCommonResultDto implements INhaCungCapVeDtoCommonResultDto {
    dataResult!: NhaCungCapVeDto;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: INhaCungCapVeDtoCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"] ? NhaCungCapVeDto.fromJS(_data["dataResult"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): NhaCungCapVeDtoCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapVeDtoCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface INhaCungCapVeDtoCommonResultDto {
    dataResult: NhaCungCapVeDto;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class PagingListNhaCungCapXeRequest implements IPagingListNhaCungCapXeRequest {
    soSaoDanhGia!: number | undefined;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingListNhaCungCapXeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.soSaoDanhGia = _data["soSaoDanhGia"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingListNhaCungCapXeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingListNhaCungCapXeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["soSaoDanhGia"] = this.soSaoDanhGia;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingListNhaCungCapXeRequest {
    soSaoDanhGia: number | undefined;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class NhaCungCapXeDto implements INhaCungCapXeDto {
    ma!: string | undefined;
    ten!: string | undefined;
    tinhTrang!: boolean;
    quocGiaId!: number | undefined;
    tinhId!: number | undefined;
    diaChi!: string | undefined;
    email!: string | undefined;
    fax!: string | undefined;
    website!: string | undefined;
    moTa!: string | undefined;
    anhDaiDienUrl!: string | undefined;
    taiLieuJson!: string | undefined;
    isHasVAT!: boolean;
    dichVu!: string | undefined;
    soSaoDanhGia!: number | undefined;
    maSoThue!: string | undefined;
    ngayHetHanHopDong!: DateTime;
    id!: number;

    constructor(data?: INhaCungCapXeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.tinhTrang = _data["tinhTrang"];
            this.quocGiaId = _data["quocGiaId"];
            this.tinhId = _data["tinhId"];
            this.diaChi = _data["diaChi"];
            this.email = _data["email"];
            this.fax = _data["fax"];
            this.website = _data["website"];
            this.moTa = _data["moTa"];
            this.anhDaiDienUrl = _data["anhDaiDienUrl"];
            this.taiLieuJson = _data["taiLieuJson"];
            this.isHasVAT = _data["isHasVAT"];
            this.dichVu = _data["dichVu"];
            this.soSaoDanhGia = _data["soSaoDanhGia"];
            this.maSoThue = _data["maSoThue"];
            this.ngayHetHanHopDong = _data["ngayHetHanHopDong"] ? DateTime.fromISO(_data["ngayHetHanHopDong"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NhaCungCapXeDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapXeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["tinhTrang"] = this.tinhTrang;
        data["quocGiaId"] = this.quocGiaId;
        data["tinhId"] = this.tinhId;
        data["diaChi"] = this.diaChi;
        data["email"] = this.email;
        data["fax"] = this.fax;
        data["website"] = this.website;
        data["moTa"] = this.moTa;
        data["anhDaiDienUrl"] = this.anhDaiDienUrl;
        data["taiLieuJson"] = this.taiLieuJson;
        data["isHasVAT"] = this.isHasVAT;
        data["dichVu"] = this.dichVu;
        data["soSaoDanhGia"] = this.soSaoDanhGia;
        data["maSoThue"] = this.maSoThue;
        data["ngayHetHanHopDong"] = this.ngayHetHanHopDong ? this.ngayHetHanHopDong.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface INhaCungCapXeDto {
    ma: string | undefined;
    ten: string | undefined;
    tinhTrang: boolean;
    quocGiaId: number | undefined;
    tinhId: number | undefined;
    diaChi: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    website: string | undefined;
    moTa: string | undefined;
    anhDaiDienUrl: string | undefined;
    taiLieuJson: string | undefined;
    isHasVAT: boolean;
    dichVu: string | undefined;
    soSaoDanhGia: number | undefined;
    maSoThue: string | undefined;
    ngayHetHanHopDong: DateTime;
    id: number;
}

export class NhaCungCapXeDtoPagedResultDto implements INhaCungCapXeDtoPagedResultDto {
    totalCount!: number;
    items!: NhaCungCapXeDto[] | undefined;

    constructor(data?: INhaCungCapXeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NhaCungCapXeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NhaCungCapXeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapXeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface INhaCungCapXeDtoPagedResultDto {
    totalCount: number;
    items: NhaCungCapXeDto[] | undefined;
}

export class CreateOrUpdateNhaCungCapXeRequest implements ICreateOrUpdateNhaCungCapXeRequest {
    ma!: string | undefined;
    ten!: string | undefined;
    tinhTrang!: boolean;
    quocGiaId!: number | undefined;
    tinhId!: number | undefined;
    diaChi!: string | undefined;
    email!: string | undefined;
    fax!: string | undefined;
    website!: string | undefined;
    moTa!: string | undefined;
    anhDaiDienUrl!: string | undefined;
    taiLieuJson!: string | undefined;
    isHasVAT!: boolean;
    dichVu!: string | undefined;
    soSaoDanhGia!: number | undefined;
    maSoThue!: string | undefined;
    ngayHetHanHopDong!: DateTime;
    id!: number;

    constructor(data?: ICreateOrUpdateNhaCungCapXeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ma = _data["ma"];
            this.ten = _data["ten"];
            this.tinhTrang = _data["tinhTrang"];
            this.quocGiaId = _data["quocGiaId"];
            this.tinhId = _data["tinhId"];
            this.diaChi = _data["diaChi"];
            this.email = _data["email"];
            this.fax = _data["fax"];
            this.website = _data["website"];
            this.moTa = _data["moTa"];
            this.anhDaiDienUrl = _data["anhDaiDienUrl"];
            this.taiLieuJson = _data["taiLieuJson"];
            this.isHasVAT = _data["isHasVAT"];
            this.dichVu = _data["dichVu"];
            this.soSaoDanhGia = _data["soSaoDanhGia"];
            this.maSoThue = _data["maSoThue"];
            this.ngayHetHanHopDong = _data["ngayHetHanHopDong"] ? DateTime.fromISO(_data["ngayHetHanHopDong"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateNhaCungCapXeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateNhaCungCapXeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ma"] = this.ma;
        data["ten"] = this.ten;
        data["tinhTrang"] = this.tinhTrang;
        data["quocGiaId"] = this.quocGiaId;
        data["tinhId"] = this.tinhId;
        data["diaChi"] = this.diaChi;
        data["email"] = this.email;
        data["fax"] = this.fax;
        data["website"] = this.website;
        data["moTa"] = this.moTa;
        data["anhDaiDienUrl"] = this.anhDaiDienUrl;
        data["taiLieuJson"] = this.taiLieuJson;
        data["isHasVAT"] = this.isHasVAT;
        data["dichVu"] = this.dichVu;
        data["soSaoDanhGia"] = this.soSaoDanhGia;
        data["maSoThue"] = this.maSoThue;
        data["ngayHetHanHopDong"] = this.ngayHetHanHopDong ? this.ngayHetHanHopDong.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrUpdateNhaCungCapXeRequest {
    ma: string | undefined;
    ten: string | undefined;
    tinhTrang: boolean;
    quocGiaId: number | undefined;
    tinhId: number | undefined;
    diaChi: string | undefined;
    email: string | undefined;
    fax: string | undefined;
    website: string | undefined;
    moTa: string | undefined;
    anhDaiDienUrl: string | undefined;
    taiLieuJson: string | undefined;
    isHasVAT: boolean;
    dichVu: string | undefined;
    soSaoDanhGia: number | undefined;
    maSoThue: string | undefined;
    ngayHetHanHopDong: DateTime;
    id: number;
}

export class GetNCCXeByIdRequest implements IGetNCCXeByIdRequest {
    id!: number;

    constructor(data?: IGetNCCXeByIdRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetNCCXeByIdRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetNCCXeByIdRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IGetNCCXeByIdRequest {
    id: number;
}

export class NhaCungCapXeDtoCommonResultDto implements INhaCungCapXeDtoCommonResultDto {
    dataResult!: NhaCungCapXeDto;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: INhaCungCapXeDtoCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"] ? NhaCungCapXeDto.fromJS(_data["dataResult"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): NhaCungCapXeDtoCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NhaCungCapXeDtoCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface INhaCungCapXeDtoCommonResultDto {
    dataResult: NhaCungCapXeDto;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class PagingTepDinhKemRequest implements IPagingTepDinhKemRequest {
    idDanhMuc!: number;
    loaiDanhMuc!: number;
    filter!: string | undefined;
    isActive!: boolean | undefined;
    readonly filterFullText!: string | undefined;
    readonly mySqlFullTextSearch!: string | undefined;
    sorting!: string | undefined;
    skipCount!: number;
    maxResultCount!: number;

    constructor(data?: IPagingTepDinhKemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idDanhMuc = _data["idDanhMuc"];
            this.loaiDanhMuc = _data["loaiDanhMuc"];
            this.filter = _data["filter"];
            this.isActive = _data["isActive"];
            (<any>this).filterFullText = _data["filterFullText"];
            (<any>this).mySqlFullTextSearch = _data["mySqlFullTextSearch"];
            this.sorting = _data["sorting"];
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
        }
    }

    static fromJS(data: any): PagingTepDinhKemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingTepDinhKemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idDanhMuc"] = this.idDanhMuc;
        data["loaiDanhMuc"] = this.loaiDanhMuc;
        data["filter"] = this.filter;
        data["isActive"] = this.isActive;
        data["filterFullText"] = this.filterFullText;
        data["mySqlFullTextSearch"] = this.mySqlFullTextSearch;
        data["sorting"] = this.sorting;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data;
    }
}

export interface IPagingTepDinhKemRequest {
    idDanhMuc: number;
    loaiDanhMuc: number;
    filter: string | undefined;
    isActive: boolean | undefined;
    filterFullText: string | undefined;
    mySqlFullTextSearch: string | undefined;
    sorting: string | undefined;
    skipCount: number;
    maxResultCount: number;
}

export class TepDinhKemDto implements ITepDinhKemDto {
    tenGoc!: string | undefined;
    tenLuuTru!: string | undefined;
    dinhDang!: string | undefined;
    duongDan!: string | undefined;
    duongDanTuyetDoi!: string | undefined;
    id!: number;

    constructor(data?: ITepDinhKemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenGoc = _data["tenGoc"];
            this.tenLuuTru = _data["tenLuuTru"];
            this.dinhDang = _data["dinhDang"];
            this.duongDan = _data["duongDan"];
            this.duongDanTuyetDoi = _data["duongDanTuyetDoi"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TepDinhKemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TepDinhKemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenGoc"] = this.tenGoc;
        data["tenLuuTru"] = this.tenLuuTru;
        data["dinhDang"] = this.dinhDang;
        data["duongDan"] = this.duongDan;
        data["duongDanTuyetDoi"] = this.duongDanTuyetDoi;
        data["id"] = this.id;
        return data;
    }
}

export interface ITepDinhKemDto {
    tenGoc: string | undefined;
    tenLuuTru: string | undefined;
    dinhDang: string | undefined;
    duongDan: string | undefined;
    duongDanTuyetDoi: string | undefined;
    id: number;
}

export class TepDinhKemDtoPagedResultDto implements ITepDinhKemDtoPagedResultDto {
    totalCount!: number;
    items!: TepDinhKemDto[] | undefined;

    constructor(data?: ITepDinhKemDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TepDinhKemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TepDinhKemDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TepDinhKemDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITepDinhKemDtoPagedResultDto {
    totalCount: number;
    items: TepDinhKemDto[] | undefined;
}

export class TepDinhKemDtoCommonResultDto implements ITepDinhKemDtoCommonResultDto {
    dataResult!: TepDinhKemDto;
    isSuccessful!: boolean;
    errorCode!: string | undefined;
    errorMessage!: string | undefined;
    exceptionError!: string | undefined;

    constructor(data?: ITepDinhKemDtoCommonResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataResult = _data["dataResult"] ? TepDinhKemDto.fromJS(_data["dataResult"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.exceptionError = _data["exceptionError"];
        }
    }

    static fromJS(data: any): TepDinhKemDtoCommonResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TepDinhKemDtoCommonResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataResult"] = this.dataResult ? this.dataResult.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["exceptionError"] = this.exceptionError;
        return data;
    }
}

export interface ITepDinhKemDtoCommonResultDto {
    dataResult: TepDinhKemDto;
    isSuccessful: boolean;
    errorCode: string | undefined;
    errorMessage: string | undefined;
    exceptionError: string | undefined;
}

export class CreatePaymentVNPayRequest implements ICreatePaymentVNPayRequest {
    tenKhachHang!: string | undefined;
    quocGiaId!: string | undefined;
    soDienThoai!: string | undefined;
    email!: string | undefined;
    diaChi!: string | undefined;
    tourId!: number;
    tenTour!: string | undefined;
    ngayBatDau!: string | undefined;
    soLuongNguoiLon!: number;
    gia!: number;
    thanhTien!: number;

    constructor(data?: ICreatePaymentVNPayRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenKhachHang = _data["tenKhachHang"];
            this.quocGiaId = _data["quocGiaId"];
            this.soDienThoai = _data["soDienThoai"];
            this.email = _data["email"];
            this.diaChi = _data["diaChi"];
            this.tourId = _data["tourId"];
            this.tenTour = _data["tenTour"];
            this.ngayBatDau = _data["ngayBatDau"];
            this.soLuongNguoiLon = _data["soLuongNguoiLon"];
            this.gia = _data["gia"];
            this.thanhTien = _data["thanhTien"];
        }
    }

    static fromJS(data: any): CreatePaymentVNPayRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentVNPayRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenKhachHang"] = this.tenKhachHang;
        data["quocGiaId"] = this.quocGiaId;
        data["soDienThoai"] = this.soDienThoai;
        data["email"] = this.email;
        data["diaChi"] = this.diaChi;
        data["tourId"] = this.tourId;
        data["tenTour"] = this.tenTour;
        data["ngayBatDau"] = this.ngayBatDau;
        data["soLuongNguoiLon"] = this.soLuongNguoiLon;
        data["gia"] = this.gia;
        data["thanhTien"] = this.thanhTien;
        return data;
    }
}

export interface ICreatePaymentVNPayRequest {
    tenKhachHang: string | undefined;
    quocGiaId: string | undefined;
    soDienThoai: string | undefined;
    email: string | undefined;
    diaChi: string | undefined;
    tourId: number;
    tenTour: string | undefined;
    ngayBatDau: string | undefined;
    soLuongNguoiLon: number;
    gia: number;
    thanhTien: number;
}

export class Body implements IBody {
    userName!: string;
    password!: string;

    [key: string]: any;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userName = _data["UserName"];
            this.password = _data["Password"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["UserName"] = this.userName;
        data["Password"] = this.password;
        return data;
    }
}

export interface IBody {
    userName: string;
    password: string;

    [key: string]: any;
}

export class Body2 implements IBody2 {
    userName!: string;
    password!: string;

    [key: string]: any;

    constructor(data?: IBody2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userName = _data["UserName"];
            this.password = _data["Password"];
        }
    }

    static fromJS(data: any): Body2 {
        data = typeof data === 'object' ? data : {};
        let result = new Body2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["UserName"] = this.userName;
        data["Password"] = this.password;
        return data;
    }
}

export interface IBody2 {
    userName: string;
    password: string;

    [key: string]: any;
}

export class Body3 implements IBody3 {
    access_token!: string | undefined;
    refresh_token!: string | undefined;

    [key: string]: any;

    constructor(data?: IBody3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.access_token = _data["access_token"];
            this.refresh_token = _data["refresh_token"];
        }
    }

    static fromJS(data: any): Body3 {
        data = typeof data === 'object' ? data : {};
        let result = new Body3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["access_token"] = this.access_token;
        data["refresh_token"] = this.refresh_token;
        return data;
    }
}

export interface IBody3 {
    access_token: string | undefined;
    refresh_token: string | undefined;

    [key: string]: any;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}